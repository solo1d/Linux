- [内核中的时间概念](#内核中的时间概念)
- [节拍率HZ](#节拍率HZ)
- [jiffies](#jiffies)
- [硬时钟和定时器](#硬时钟和定时器)
- [时钟中断处理程序的实现](#时钟中断处理程序的实现)
- 











- **系统定时器:  一种可编程硬件芯片, 它能以固定频率产生中断**  
  - **这个中断就是所谓的 ==定时器中断== ,  它所对应的中断处理程序负责更新系统时间, 也负责执行周期性 运行的任务**
    - **系统定时器和 时钟中断处理程序时Linux系统内核管理机制中的中枢**
- **动态定时器:  一种用来推迟执行程序工具**
  - **内核可以动态创建或撤销动态定时器**
- **内核中所有的时间概念都来源于周期运行的系统时钟**
- ==**平均误差  就是可能浪费的时间,  是时钟中断周期的一半**==
- **一秒钟内 时钟中断的次数  等于HZ**
- **内核 很少使用绝对时间**
- **当前实际时间 就是墙上时间**

# 内核中的时间概念

- **内核必须在硬件的帮助下才能计算和管理时间**
  - **硬件为内核提供了一个系统定时器  用来计算流逝的时间,  该时钟在内核中可看成是一个电子时间资源** 
    - **比如 数字时钟和处理器频率等**
- ==**节拍率**== :**系统定时器 以某种频率自行触发 `(可称为击中或射中)`  时钟中断, 这个频率可以通过编程预定 **
  - ==**当时钟中断发生时, 内核就通过一种特殊的中断处理程序对其进行处理**==
  - ==**节拍:**==  因为预编的节拍率对内核来说是可知的，所以内核知道  **连续两次时钟中断的间隔时间**。这个间隔时间就称为节拍（tick），它等于 节拍率分之一（ 1/ (tick rate））秒。
    - **内核就是靠这种已知的时钟中断间隔来计算  ==墙上时间== 和 ==系统运行时间==**
      - ==**墙上时间:**== 也就是**实际时间** 现实时间, 对用户空间的应用程序来说是最重要的。**该时间存放在 time 变量中**
        - 内核通过控制时钟中断维护实际时间，
        - 内核也为用户空间提供了一组系统调用以获取实际日期和实际时间。
      - ==**系统运行时间:**==（**自系统启动开始所经的时间**）对用户空间和内核都很有用，因为许多程序都必须清楚流逝的时间。
        - **相对的流逝的时间计算:** 通过两次（现在和以后）读取运行时间再计算它们的差，就可以得到
      - **系统运行时间以秒为单位计算, 就等于 $jiffies/HZ$**

>- **时钟中断对于管理操作系统尤为重要，大量内核函数的生命周期都离不开流近的时间的控制。**
>- **下面是一些利用 ==时间中断周期== 执行的工作：**
>  - 更新系统运行时间。
>  - 更新实际时间。
>  - 在 smp 系统上，均衡调度程序中各处理器上的运行队列,  如果运行队列负载不均衡的话，尽量使它们均衡.
>  - 检査当前进程是否用尽了自己的时间片。如果用尽，就重新进行调度
>  - 运行超时的动态定时器。
>  - **更新资源消耗和处理器时间的统计值。**
>- 这其中有些工作在毎次的时钟中断处理程序中都要被处理, 也就是说，这些工作随时钟的频率反复运行。另一些也是周期性地执行，但只需要每 n 次时钟中断运行一次，也就是说，这些函数在累计了一定数量的时钟节拍数时才被执行。



# 节拍率HZ

- **系统定时器频率 (节拍率)  是通过 ==静态预处理定义== 的, 也就是HZ(赫兹),在系统启动时按照HZ 值对硬件进行设置**
  - 处理器的体系结构不同, HZ的值也不同
  - 节拍率有一个HZ频率,一个周期为 `1/HZ` 秒。
    - 例如，x86 体系结构中，系统定时器频率默认值为 100。因此，x86 上时钟中断的频率就为 100HZ，也就是说在 i386 处理上的毎秒钟时钟中断 100 次（百分之一秒，即每 10ms 产生一次）。但其他体系结构的节拍率为 250 和 1000, 分别对应 4ms 和 1ms。
  - ==**HZ值是可调的, 并不是固定不变, 編写内核代码时, 大多数体系结构的节拍率都是可调的**==
  - ==**在 2.6 版内核中还是允许在编译内核时选定不同的 HZ 值**==

```c
#include <arch/x86/include/sam/param.h>  // HZ定义 , 根处理器的体系结构相关

# define HZ		CONFIG_HZ	/* 内部内核定时器频率*/
# define USER_HZ	100		/* 用户看到的HZ频率值 */
# define CLOCKS_PER_SEC	(USER_HZ)       /* in "ticks" like times() */

// 内核使用 jiffies_64_to_clock_t() 将64位 的jiffies值的单位从 HZ 转换为 USER_HZ, 方便计算
   u64 jiffies_64_to_clock_t(u64 x);

// 例子: 把 节拍数/HZ 得到的 经过了多少节拍
  unsigned long total_time  , start = jiffies 
   /* 中间执行了一些任务, 消耗了一些时间 */
  totla_time = jiffies - start;
  printk("这花了 %lu 节拍\n", jiffies_64_to_clock_t(total_time));
  printk("这花了 %lu 秒\n", total_time / HZ);
```

- 系统定时器使用 **高频率** 与 使用 **低频率**  的优劣:
  - ==高频率 HZ 的好处:==
    - 提高节拍率意味着时钟中断产生得更加频繁，所以中断处理程序也会更频地执行。如此来会给整个系统带来如下 **好处**：
      - 更高的时钟中断解析度（resolution）可提高时间驱动事件的解析度
        - 提高节拍率等同于提高中断解析度。比如 HZ=100 的时钟的执行粒度为 10ms，即系统中的周期事件最快为每 10ms 运行一次，而不可能有更高的精度，但是当 HZ=1000 时，解析度就为1ms 精细了 10 倍。内核可以提供频度为 1ms 的时钟.
      - 提高了时间驱动事件的准确度（accuracy）。
        - 触发定时器会更加精准, 误差更小, 平均误差也会更小
    - **更高的时钟中断频度和更高的准确度又会来如下优点：**
      - 内核定时器能够以更高的频度和更高的准确度运行。
      - 依赖定时值执行的系统调用，比如 pol 和 selecto，能够以更高的精度运行。
      - 对诸如资源消耗和系统运行时间等的测量会有更精细的解析度提高进程抢占的准确度。
      - 提高精度可以大幅度提高系统性能
      - 更高的准确率也使进程抢占更准确，同时还会加快调度响应时间
        - **时钟中断处理程序负责减少当前进程的时间片计数。**
          - 当时间片计数跌到 0 时，而又设置了 need_resched 标志的话，内核便立刻重新运行调度程序。
            - 假定有一个正在运行的进程，它的时间片只剩下 2ms 了，此时调度程序又要求抢占该进程，然后去运行另一个新进程；然而，该抢占行为不会在下个时钟中断到来前发生，也就是说，在这 2ms 内不可能进行抢占。实际上，对于频率为 100HZ 的时钟来说，最坏要在 10ms 后，当下一个时钟中断到来时才能进行抢占，所以新进程也就可能要比要求的晚 10ms 才能执行。当然，进程之间也是平等的，因为所有的进程都是一视同仁的待遇，调度起来都不是很准确但关不在于此。问题在于由于耽误了抢占，所以对于类似于填充音频缓冲区这样有严格时间要求的任务来说，结果是无法接受的。如果将节拍率提高到 1000Z，在最坏情况下，也能将调度延误时间降低到 ms，而在平均情况下，只能降到 0.5ms 左右。
  - ==高频率 HZ 的坏处:==
    - **节拍率越高，意味着时钟中断频率越高，就意味着系统负担越重**
    - 因为处理器必须花时间来执行时钟中断处理程序，所以节拍率越高，中断处理程序占用的处理器的时间越多。
    - 减少处理器处理其他工作的时间，而且还会更频繁地打乱处理器高速缓存并增加耗电。
    - 将时钟频率从 100HZ 提高到 1000HZ 必然会使时钟中断的负载增加 10 倍。



# jiffies

- **全局变量 jiffies 用来记录自系统启动以来产生的节拍的总数。**
  - 启动时 , 内核将该变量初始化为一个特殊值,让它不断溢出,  由此捕捉异常，但每次时钟中断处理程序就会增加该变量的值。
    - **找到这个值的时候, 需要先把这个内核加上的 偏差值  减去  才可正常使用**
  - **一秒钟内 时钟中断的次数  等于HZ, jiffies 一秒内增加的值也为HZ**
  - **系统运行时间以秒为单位计算, 就等于  $(jiffies/HZ)$**
- **用户空间使用的HZ 和系统的HZ 不一样. 但可以互相转换**

```c
#include <include/linux/jiffies.h>
#define __jiffy_data  __attribute__((section(".data")))

// 64位体系结构是64位, 32位体系结构是32位(100HZ 下会在497天溢出 0xFFFFFFFF/100/60/60/24=497 )
// 大多数代码只关系 低32位 来使用 流失的时间
extern unsigned long volatile __jiffy_data  jiffies;  
extern u64 __jiffy_data jiffies_64;  // 64位体系结构下, 他和 jiffies指向同一变量,作用相同


// 将以秒为单位的时间 转化为 jiffies  , 这个在内核里常用
( seconds * HZ)

// 将 jiffies 转换为 以秒为单位的时间 , 经常用在内核和用户空间进行交互的时候.
( jiffies / HZ )


// 设置一些将来的时间
unsigned long time_stamp = jiffies;      // 现在
unsigned long time_data = jiffies/HZ;    // 从开机到现在 过去了多长时间 (有可能要减去某个特殊值)
unsigned long next_tick = jiffies + 1;   // 从现在开始的一个节拍
unsigned long later = jiffies + 5*HZ;    // 从现在开始 5 秒
unsigned long fraction = jiffies + HZ/10;  // 从现在开始 1/10 秒



// 读取整个 64位 jiffies 的值 ( 32位体系结构下是 32位),  也可以直接读取 jiffies 变量来获得
		u64 get_jiffies_64(void);


// 当 jiffies 发生溢出  回绕到 0时, 可以通过下面的宏来进行正确的处理
//  比较的时候用这些宏可以避免jiffies由于过大造成的回绕问题。
// unknown 通常为 jiffies,  known是需要对比的值, 如果有参数为0   则直接返回 0

long time_after(unknown, known)	 ((long)(known) - (long)(unknown) < 0)
    // 当时间 unknow 超过指定的 know 时, 返回真, 否则假
long time_before(unknown, known)	 ((long)(unknown) - (long)(known) < 0)
      // 当时间 unknow 没超过指定的 know 时, 返回真, 否则假
long time_after_eq(unknown, known)	 ((long)(unknown) - (long)(known) >= 0)
      // 当时间 unknow 与 know 相等时, 返回真, 否则假
long time_before_eq(unknown, known)	 ((long)(known) - (long)(unknown) >= 0)
      // 当时间 unknow 与 know 相等时, 返回真, 否则假
  
  
// 例子:
    unsigned long timeout = jiffies + HZ/2;
       /* 中间执行了一些任务, 消耗了一些时间 */
    if(time_before(jiffies, timeout)){
       // 没有超时
    } else{
       // 超时了  发生错误
    }
  
```



# 硬时钟和定时器

- **实时时钟 `RTC`   是个硬件, 用来存放持久系统时间的设备, 靠主板的2032电池保持供电和系统的计时**
  - RTC 一般和 CMOS集成在一起, RTC 的运行和 BIOS 的保存设置都是通过同一个电池供电的。
  - ==**实时时钟最主要的作用仍是在启动时初始化 xtime 变量。**==
    - ==当系统启动时，内核通过读取 RTC 来初始化墙上时间，该时间存放在 **xtime** 变量中。==
  - 内核通常不会在系统启动后再读取 xime 变量，但是有些体系结构（比如 x86) 会周期性地将当前时间值存回 RTC 中。
- **系统定时器 是一个硬件,  是内核定时机制中最为重要的角色, 提供一种周期性触发中断机制**
  - **通过对电子晶振进行分频来实现系统定时器，还有些体系结构则提供了一个衰减测量器(decrementer）衰减测量器设置一个初始值，该值以固定频率递减，当减到零时，触发一个中断。无论哪种情况，其效果都一样**
  - 在 x86 体系结构中，主要采用可编程中断时钟（PIT）。PT 在 PC 机器中普遍存在，而且从 DOS 时代，就开始以它作为时钟中断源了。
  - 内核在启动时对 PIT 进行编程初始化, 使其能够以 HZ/秒的频率产生时钟中断(中断O)。虽然PT设备很简单,功能也有限，但它却足以满足我们的需要。x86 体系结构中的其他的时钟资源还包括本地 APIC 时钟和时间戳计数（TSC）等。



# 时钟中断处理程序的实现

- **时钟中断处理程序可以划分为两部分:   体系结构相关部分和体系结构无关部分**
  - **体系结构相关部分**
    - 与体系结构相关的例程作为系统定时器的中断处理程序而注册到内核中，以便在产生时钟中断时，它能够相应地运行。	
    - ==**绝大多数处理程序最低限度也都要执行如下工作：**==
      - 获得 time_lock 锁，以便对访问 jiffies_64 和墙上时间 time 进行保护
      - 需要时应答或重新设置系统时钟。
      - 周期性地使用墙上时间更新实时时钟。 xtime
      - **调用体系结构无关的时钟例程：`tick_periodic()`**
        - ==**中断服务程序主要通过调用与体系结构无关的例程，`tick_periodico()` 执行下面更多的工作:**==
          - 给 jiffies_64 变量增加 1（这个操作即使是在 32 位体系结构上也是安全的，因为前面已经获得了 time_lock 锁）
          - **更新资源消耗的统计值，比如当前进程所消耗的系统时间和用户时间。**
          - **执行已经到期的动态定时器**
          - 执行 `sheduler_tick()` 函数
          - **更新墙上时间，该时间存放在 time 变量中**
          - **计算平均负载值。**
  - **体系结构无关部分**
    - 



**下面的全部函数和工作 在每  `( 1/HZ )秒`  都要发生一次, 100HZ 就表示会发生 100次  , 从函数 `tick_periodic()` 开始**

```c
/*  #include <kernel/sched.c>
 * 负责减少当前运行进程的时间片计数值 并且在需要时设置 need_resched 标志.
 *  在SMP机器中, 还要负责平衡每个处理器上的运行队列
 * 此函数由定时器代码调用，频率为 HZ。
 * 我们在禁用中断的情况下调用它。
 * 在更改父级的时间片时，它也会被 fork 代码调用。
 */
void scheduler_tick(void)
{
	int cpu = smp_processor_id();
	struct rq *rq = cpu_rq(cpu);
	struct task_struct *curr = rq->curr;

	sched_clock_tick();

	raw_spin_lock(&rq->lock);
	update_rq_clock(rq);
	update_cpu_load(rq);
	curr->sched_class->task_tick(rq, curr, 0);
	raw_spin_unlock(&rq->lock);

	perf_event_task_tick(curr);

#ifdef CONFIG_SMP
	rq->idle_at_tick = idle_cpu(cpu);
	trigger_load_balance(rq, cpu);
#endif
}



/* #include <kernel/timer.c>
 * 64 位 jiffies 值不是原子的 - 您不得在不对 xtime_lock 中的序列号进行采样的情况下读取它。
 *   jiffies 在链接描述文件中定义...
 * 更新 jiffies_64 墙上时间, 和计算全局负载
 */
void do_timer(unsigned long ticks)
{
	jiffies_64 += ticks;
	update_wall_time();  //  根据所流的时间更新 jiffies_64 墙上时间
	calc_global_load();  // 更新系统的平均负载统计值。
}


/* #include <kernel/sched.c>
 * 对进程的时间进行实质性更新
 * 计算 CPU 时间的一个滴答。
 * @p：cpu 时间占用的进程
 * @user_tick: 表示tick是用户还是系统tick
 */
void account_process_tick(struct task_struct *p, int user_tick)
{
	cputime_t one_jiffy_scaled = cputime_to_scaled(cputime_one_jiffy);
	struct rq *rq = this_rq();

	if (user_tick)
		account_user_time(p, cputime_one_jiffy, one_jiffy_scaled);
	else if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))
		account_system_time(p, HARDIRQ_OFFSET, cputime_one_jiffy,
				    one_jiffy_scaled);
	else
		account_idle_time(cputime_one_jiffy);
}




/* #include <kernel/timer.c >
 * 从定时器中断处理程序中调用，以向当前进程更新节拍数。 
 * user_tick 如果是用户时间，则为 1，系统为 0。 表示这个时间是花费在 内核还是用户空间,但不准确
 * user_tick 是通过查看 系统寄存器 来设置的
 */
void update_process_times(int user_tick)
{
	struct task_struct *p = current;
	int cpu = smp_processor_id();

	/* 注意：这个计时器 irq中断请求 上下文也必须考虑在内, 对这个 时钟的irq中断请求 的上下文 说明原因*/
	account_process_tick(p, user_tick);  // 对进程的时间进行实质性更新
	run_local_timers();   // 标记了一个软中断 去处理所有到期的定时器
	rcu_check_callbacks(cpu, user_tick);
	printk_tick();
	perf_event_do_pending();
	scheduler_tick();
	run_posix_cpu_timers(p);
}



/* #include <kernel/time/tick-common.c >
 * 定期节拍
 * 函数执行完毕后返回与体系结构相关的中断处理程序，继续执行后面的工作释放 time_lock 锁，然后退出。
 */
static void tick_periodic(int cpu)
{
	if (tick_do_timer_cpu == cpu) {
		write_seqlock(&xtime_lock);   // 获得顺序锁 的写锁

		/* 记录下一个节拍事件 */
		tick_next_period = ktime_add(tick_next_period, tick_period);

		do_timer(1); // 对 jiffies_64 的更新 增加
		write_sequnlock(&xtime_lock);  // 释放 顺序锁的写锁
	}
  
	/* 更新所消耗的 各种节拍数
	 * user_tick 是通过查看 系统寄存器 来设置的
	 */
	update_process_times(user_mode(get_irq_regs()));
  
	profile_tick(CPU_PROFILING);  // 什么都不做 直接return
}

```





## 实际时间

**当前实际时间 就是墙上时间, 定义在 `<kernel/time/timekeeping.c>` 中**

```c
#include <kernel/time/timekeeping.c> 
struct timespec xtime ;  
/* 实际时间( 墙上时间) 会放到这个结构里面 
 * 读写 time 变量需要使用 time_lock 锁，该锁不是普通自旋锁而是一个 seqlock 顺序锁，
 * 下面有更新范例细节
 */



#include <include/linux/time.h>
struct timespec {
	__kernel_time_t	tv_sec;		/* seconds 秒 ,存放着从 1970年1月1日(UTC) 以来经过的时间(纪元) 秒数*/
	long		tv_nsec;		/* nanoseconds 纳秒, 记录自上一秒开始经过的 纳秒数*/
};






//更新 xtime 首先要申请一个 seqlock 顺序锁
write_seqlock(&xtime_lock);
  /* 更新 xtime,   xtime=xxxx; */
write_sequnlock(&xtime_lock);

// 读取 xtime 要使用 read_seqbegin() 和 read_seqretry() 函数
  unsigned long seq;
  do {
     unsigned long lost;
     seq = read_seqbegin(&xtime_lock);
     usec = timer->get_offset();
     lost = jiffies - wall_jiffies;
     if(lost)
        usec += lost * (1000000 / HZ);
     sec = xtime.tv_sec;
     usec += (xtime.tv_nsec / 1000);
  }while (read_seqretry(&xtime_lock, seq));
   // 该循环不断重复，直到读者确认读取数据时没有写操作介入  才会返回.
   // 如果发现循环期间有时钟中断处理程序更新 xime，那么 read_seqretryo 函数就返回无效序列号,继续循环等待.
```



















