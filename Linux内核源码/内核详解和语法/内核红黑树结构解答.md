**Linux 实现的红黑树称为 rbtree**

**头文件 `<include/linux/rbtree.h>`**

**实现文件  `<lib/rbtree.c>`**

```c

#include <stdio.h>
#include <iostream>
#include <unistd.h>


// 这个结构体是 节点
struct rb_node
{
    unsigned long  rb_parent_color;
#define    RB_RED        0
#define    RB_BLACK    1
    struct rb_node *rb_right;
    struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));
    /* 对齐可能看起来毫无意义，但据称 CRIS 需要它 */


// 用于初始化 根节点 rb_root结构体的 宏
#define RB_ROOT    (struct rb_root) { NULL, }

// 这个结构体是 根节点
struct rb_root
{
    struct rb_node *rb_node;
};

struct page{
    unsigned long offset;
    struct rb_node rb_page_cache;
};

struct inode{
    struct rb_root i_rb_page_cache;   // 树root
    struct page* rb_page_cache;
};


/**
 * container_of - 将结构的成员投射到包含结构中
  * @ptr：指向成员的指针。
  * @type：嵌入的容器结构的类型。
  * @member：结构中成员的名称。
 *
 */
#define container_of(ptr, type, member) ({            \
    const typeof(((type *)0)->member) * __mptr = (ptr);    \
    (type *)((char *)__mptr - offsetof(type, member)); })


// container_of(ptr, type, member)  定义在内核  </tools/perf/uiil/include/linux/kernel.h>
#define    rb_entry(ptr, type, member) container_of(ptr, type, member)


// 搜索 操作
struct page* rb_search_page_cache( struct inode *inode, unsigned long offset){
    struct  rb_node* n = inode->i_rb_page_cache.rb_node;
    
    struct page* page = nullptr;
    while (n) {
        page = rb_entry( n, struct page, rb_page_cache );
        if(offset < page->offset )
            n = n->rb_left;
        else if (offset > page->offset )
            n = n ->rb_right;
        else
            return page;
    }
    
    return  nullptr;
}

// 具体的插入节点操作
static inline void rb_link_node(struct rb_node * node, struct rb_node * parent,
                struct rb_node ** rb_link)
{
    node->rb_parent_color = (unsigned long )parent;
    node->rb_left = node->rb_right = NULL;

    *rb_link = node;
}


void rb_insert_color(struct rb_node *node, struct rb_root *root);

//插入操作 ,   想要插入必须先实现搜索
static inline struct page * rb_insert_page_cache(
                           struct inode * inode,
                           unsigned long offset,
                           struct rb_node * node)
{ // inode 里面存在根节点,
    struct rb_node ** p = &inode->i_rb_page_cache.rb_node;
    struct rb_node * parent = nullptr;
    struct page * page;

    while (*p)
    {
        parent = *p;
        page = rb_entry(parent, struct page, rb_page_cache);

        if (offset < page->offset)
            p = &(*p)->rb_left;
        else if (offset > page->offset)
            p = &(*p)->rb_right;
        else
            return page; //页存在高速缓存中, 返回已存在的页结构地址
    }
    
    // 找到了插入节点, 进行插入
    rb_link_node(node, parent, p);  // 插入节点
    rb_insert_color(node, &inode->i_rb_page_cache);  // 执行平衡操作

    return nullptr;   // 页被加入到了页高速缓存中, 则返回 nullptr
}



#define rb_parent(r)   ((struct rb_node *)((r)->rb_parent_color & ~3))
#define rb_color(r)   ((r)->rb_parent_color & 1)
#define rb_is_red(r)   (!rb_color(r))
#define rb_is_black(r) rb_color(r)
#define rb_set_red(r)  do { (r)->rb_parent_color &= ~1; } while (0)
#define rb_set_black(r)  do { (r)->rb_parent_color |= 1; } while (0)
static inline void rb_set_parent(struct rb_node *rb, struct rb_node *p)
{
    rb->rb_parent_color = (rb->rb_parent_color & 3) | (unsigned long)p;
}


static void __rb_rotate_left(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *right = node->rb_right;
    struct rb_node *parent = rb_parent(node);

    if ((node->rb_right = right->rb_left))
        rb_set_parent(right->rb_left, node);
    right->rb_left = node;

    rb_set_parent(right, parent);

    if (parent)
    {
        if (node == parent->rb_left)
            parent->rb_left = right;
        else
            parent->rb_right = right;
    }
    else
        root->rb_node = right;
    rb_set_parent(node, right);
}

static void __rb_rotate_right(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *left = node->rb_left;
    struct rb_node *parent = rb_parent(node);

    if ((node->rb_left = left->rb_right))
        rb_set_parent(left->rb_right, node);
    left->rb_right = node;

    rb_set_parent(left, parent);

    if (parent)
    {
        if (node == parent->rb_right)
            parent->rb_right = left;
        else
            parent->rb_left = left;
    }
    else
        root->rb_node = left;
    rb_set_parent(node, left);
}


void rb_insert_color(struct rb_node *node, struct rb_root *root)
{
    struct rb_node *parent, *gparent;

    while ((parent = rb_parent(node)) && rb_is_red(parent))
    {
        gparent = rb_parent(parent);

        if (parent == gparent->rb_left)
        {
            {
                register struct rb_node *uncle = gparent->rb_right;
                if (uncle && rb_is_red(uncle))
                {
                    rb_set_black(uncle);
                    rb_set_black(parent);
                    rb_set_red(gparent);
                    node = gparent;
                    continue;
                }
            }

            if (parent->rb_right == node)
            {
                register struct rb_node *tmp;
                __rb_rotate_left(parent, root);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            rb_set_black(parent);
            rb_set_red(gparent);
            __rb_rotate_right(gparent, root);
        } else {
            {
                register struct rb_node *uncle = gparent->rb_left;
                if (uncle && rb_is_red(uncle))
                {
                    rb_set_black(uncle);
                    rb_set_black(parent);
                    rb_set_red(gparent);
                    node = gparent;
                    continue;
                }
            }

            if (parent->rb_left == node)
            {
                register struct rb_node *tmp;
                __rb_rotate_right(parent, root);
                tmp = parent;
                parent = node;
                node = tmp;
            }

            rb_set_black(parent);
            rb_set_red(gparent);
            __rb_rotate_left(gparent, root);
        }
    }

    rb_set_black(root->rb_node);
}



int main(void){
    // 创建并初始化一个根节点 , 就是一个结构体
    struct  rb_root root = RB_ROOT;   
    return 0;
}

```

