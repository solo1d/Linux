# 正则表达式

**正则表达式**  **`就是处理字串的方法，他是以行 为单位来进行字串的处理行为， 正则表达式通过一些特殊符号的辅助，可以让使用者轻易的达到“搜寻/删除/取代”某特定字串的处理程序!`**

**正则表达式 分为`基础正则表达式`和 `延伸正则表达式` ,延伸正则表达式可以作为群组字串的处理.**



## 基础正则表达式

*正则表达式是处理字串的一种表示方式，对字符排序有影响的语系数据就会对正则 表达式的结果有影响 .*

**正则表达式也需要支持工具程序来辅助才行** 



#### 语系对正则表达式的影响

**使用正则表 达式时，需要特别留意当时环境的语系.**

下面所有的正则表达式都符合 **`POSIX 标准`**, 需要使用 **`LANG=C`** 语系数据来进行.(**`不可以舍弃** [ ] **方括号`**)

| 特殊符號   | 代表意義                                                     |
| ---------- | ------------------------------------------------------------ |
| [:alnum:]  | 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z                 |
| [:alpha:]  | 代表任何英文大小写字符，亦即 A-Z, a-z                        |
| [:blank:]  | 代表空白键与 [Tab] 按键两者                                  |
| [:cntrl:]  | 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等     |
| [:digit:]  | 代表数字而已，亦即 0-9                                       |
| [:graph:]  | 除了空白字符 (空白键与 [Tab] 按键) 外的其他所有按键          |
| [:lower:]  | 代表小写字符，亦即 a-z                                       |
| [:print:]  | 代表任何可以被打印出来的字符                                 |
| [:punct:]  | 代表标点符号 (punctuation symbol)，亦即:" ' ? ! ; : # $...   |
| [:upper:]  | 代表大写字符，亦即 A-Z                                       |
| [:space:]  | 任何会产生空白的字符，包括空白键, [Tab], CR 等等             |
| [:xdigit:] | 代表 16 进位的数字类型，因此包括: 0-9, A-F, a-f 的数字与字符 |



#### grep 的一些进阶选项 (正则表达式)

**grep 在数据中查寻一个字串时，是以 "整行" 为 单位来进行数据的摘取的 **

```bash
$gerp  [-A] [-B] [--color=auto]  '搜寻字串‘ filename
$grep  [-acinv] [--color=auto] '搜寻字串'  filename
选项与参数:
-a   :将 binary 文件以 text 文件的方式搜寻数据
-c   :计算找到 '搜寻字串' 的次数
-i   :忽略大小写的不同，所以大小写视为相同, 默认是区分大小写的.
-n   :顺便输出行号
-v   :反向选择，亦即显示出没有 '搜寻字串' 内容的那一行!

 -A :后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来;
 -B :后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来;
 --color=auto 可将正确的那个撷取数据列出颜色


范例一:用 dmesg 列出核心讯息，再以 grep 找出内含 intel 那行并上色.
$dmesg | grep --color=auto 'intel'     #dmesg 会列出核心产生的讯息,包括硬件侦测流程也会显示出来
输出:
[    0.507864] intel_idle: does not run on family 6 model 158
[    3.928920] snd_intel8x0 0000:00:1f.4: enable Parallels VM optimization
[    4.294938] snd_intel8x0 0000:00:1f.4: intel8x0_measure_ac97_clock: measured 51555 usecs (2548 samples)
[    4.294942] snd_intel8x0 0000:00:1f.4: clocking to 46618


范例三:承上题，在关键字所在行的前两行与后三行也一起捉出来显示
$dmesg | grep -B2 -A3 --color=auto 'intel'
输出:
[    0.507054] Console: switching to colour frame buffer device 128x48
[    0.507855] fb0: EFI VGA frame buffer device
[    0.507864] intel_idle: does not run on family 6 model 158
/*....中间部分省略*/
[    4.294942] snd_intel8x0 0000:00:1f.4: clocking to 46618
[    6.756875] floppy0: no floppy controllers found
[    6.756915] work still pending
[    6.889807] type=1305 audit(1572056014.859:4): audit_pid=733 old=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:auditd_t:s0 res=1
```



#### 基础正则表达式练习

```bash
利用中括号 [] 来搜寻集合字符,  [^] 表示反向选择,
$grep  -n 't[ae]st'  reg.txt
		#会输出行号,并且会寻找 'test tast ' 这两种串
		# 无论方括号内有多少个字符,都算一个位置,相当于是一个集合.

$grep -n '[^g]oo'  reg.txt
	  #反向选择, 会检索文件内 oo 的字符串, 并且把 oo前面是g 的行拿掉.
	  	#但是, 如果该行出现了 'goooo' 这种的字串,还是会被选择出现的.因为它后面的内容符合条件.
	  	
$grep -n '[^a-z]oo'   reg.txt
		#oo前面不允许出现小写英文字符, 但是只有ASCII 才可以这么写(小写连续的).

grep -n '[^[:lower:]]oo' reg.txt
		#整段表示, 不要输出 oo 前面有小写字符的字符串行,也包括 oo 前面什么都没有的串行.
    #  [:lower:] 代表小写字符，亦即 a-z (可以避免编码问题)  , [^] 表示反向选择(排除项)



行首与行尾字符 ^ $   (这里字符不在[] 方括号里了,要注意,意义不同)
$grep -n '^the' reg.txt
		#只显示 'the' 在行首 出现的行.   ' ^ ' 表示行首

$gerp -n '^[a-z]'  reg.txt
		#只显示行首 是小写字符的行.
		# 可以这样代替 : 
					$ grep -n '^[[:lower:]]'  reg.txt

$grep -n '^[^[:alpha:]]'  reg.txt
		#只显示行首 不是英文字母 开头的行,(无论大小写),   [:alpha:] 表示所有英文字母并且无论大小写.
		# 可以这样代替 : 
					$grep -n '^[^a-z,A-Z]' reg.txt

$grep -n '\.$' reg.txt
		#只显示 行尾 是 . 结尾的行.  因为小数点是有特殊意义的,所以需要转义字符来进行处理.
			#但是要注意文本的 断行尾, unix 和dos 是不同的,需要进行转换,否则输出不正确($dos2unix)

$grep -n '^$' reg.txt
		# 只显示空行, 就是什么数据都没有的行,没有空格也没有[tab],(可以出现换行符 \n )

$grep -v '^$' /etc/rsyslog.conf | grep -v '^#'
		#去除空行, 去除行首为 # 符号的行.  -v 参数表示的是不要后面参数的行.


任意一个字符 . 与重复字符 *   ,不在[]方括号内
	. 代表 "一定有一个任意字符" 的意思      ( .* 代表任意字符)
	* 代表 "重复前一个字符,0到无数次" 的意思,( 前面必须有一个牺牲字符)
$grep -n  'g..d' reg.txt 
		 # g和d 之间必须有两个任意字符, 是必须有两个字符, 不可以多, 也不可以少

$grep -n 'goo*g' reg.txt
		# 寻找的是 : 串两边都有g 并且中间至少有一个o 或多个 o, *前面的第一个o 是牺牲字符.
		#  牺牲字符代表了两个东西,一个是字符o,另一个就是空字符. (这两者都可以无限多)
		# 如果搜索条件给出 'o*' 的话, 那么 reg.txt 文件中, 所有的内容全部都会打印出来.
		#  毕竟 * 代表的是 0个 或无数个, 那么就算这行没有o 也会被选中的.

$grep -n '^g.*g$' reg.txt 
		#寻找的是 以g 为行首, g为行尾, 无论中间字符是什么的行. 只要这行开头结尾都是g 就可以.
		
$grep -n '[0-9][0-9]*' reg.txt
		#找出 有任意数字的 行.  只要该行出现数字 那么就选中. 第二个数字就是牺牲字符.
			#和下面效果一样
				$rep -n '[0-9]' reg.txt

$ls /etc -h | grep '^[^d]' |cut -d ' ' -f9  | grep '^a.*' -n
			#寻找 /etc 下所有的 以a 开头的文件名. (不可以出现目录)
	

限定连续 RE 字符范围 {n1,n2}
  {} 因为在 shell下,这两个尖括号都有特殊意义,所以需要使用\转义字符来让他失去特殊意义才行.
  		就算脚本也要有 \转义字符 ,不可以省略.
$grep  -n 'o\{2\}'  reg.txt
			#寻找 拥有 2个以及2个以上 相连的 o 的串, 选中该行.
			# 也可以这么写, 效果相同
						$grep -n 'go\{2,\}g'  reg.txt

$grep -n 'go\{2,5\}g'  reg.txt
			#寻找 g 开头和结尾 并且中间有 2到5 个 o 的行.严格限定了 o 出现的个数. 
```















