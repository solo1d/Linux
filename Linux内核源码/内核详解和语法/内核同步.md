- [加锁](#加锁)
- [造成并发执行的原因](#造成并发执行的原因)
- [死锁](#死锁)
- [锁的争用和拓展性](#锁的争用和拓展性)
- [内核同步方法](#内核同步方法)
  - [原子操作](#原子操作)
    - [原子整数操作](#原子整数操作)
    - [原子位操作](#原子位操作)
  - [自旋锁](#自旋锁)
    - [自旋锁调试](#自旋锁调试)
  - [读写自旋锁](#读写自旋锁)
  - [信号量](#信号量)
  - [读写信号量](#读写信号量)
  - [互斥体](#互斥体)
  - [完成变量](#完成变量)
  - [BKL大内核锁](#BKL大内核锁)
  - [顺序锁](#顺序锁)
  - [禁止抢占](#禁止抢占)
  - [顺序和屏障](#顺序和屏障)



**内核抢占就是指一个在内核态运行的进程, 可能在执行内核函数期间被另一个进程取代.**



- 所谓临界区（也称为临界段）就是访问和操作共享数据的代码段。
- **代码原子地执行 : 操作在执行结東前不可被打断，就如同整个临界区是一个不可分割的指令一样。**
- 如果两个执行线程有可能处于同一个临界区中同时执行，那么这就是程序包含的一个 bug。如果这种情况确实发生了，我们就称它是 **竟争条件**（race conditions），这样命名是因为这里会存在线程竞争。
- 这种情况出现的机会往往非常小一就是因为竟争引起的错误非常不易重现，所以调试这种错误才会非常困难。避免并发和防止竟争条件称为**同步**（synchronization）。

**由于锁的作用是使程序以串行方式对资源进行访向，所以使用锁无疑会降低系统的性能.**

==**在访问共享数据之前, 一定要保证数据是安全的**==

# 加锁

- 确保一次有且只有一个线程对数据结构进行操作，或者当另一个线程在对临界区标记时，就禁止（或者说锁定）其他访问。
  - ==**对临界区的数据进行加锁, 而不是代码**==
- 锁提供的就是这种机制：它就如同一把门锁，门后的房间可想象成一个临界区。
- 锁机制可以防止并发执行，并且保护队列不受争条件的影响。
- **各种锁机制之间的区别主要在于:**
  - 当锁已经被其他线程持有，因而不可用时的行为表现
    - 一些锁被争用时会简单地执行  **忙等待**
    - 另外一些锁会使当前任务 **睡眼** 直到锁可用为止



- **锁是采用原子操作实现的, 原子操作不存在竞争**
  - 锁的实现与体系结构密切相关
  - 单一指令可以验证它的关键部分是否抓住, 如果没有的话, 就抓住它
    - **处理器在物理层面上实现了 测试和设置指令**
      - 这一指令 测试整数的值,  如果值为0, 就设置一新值
        - **称为 `compare` 和 `exchange` 类似的指令**

- **用户空间之所以需要同步，是因为用户程序会被调度程序抢占和重新调度。**



- ==**内核抢占代码使用自旋锁作为非抢占区域的标记**==

  - ==**如果一个自旋锁被持有，内核便不能进行抢占 ,因为内核抢占和 SMP 面对相同的并发问题**==

    



# 造成并发执行的原因

- **中断** , 异步发生 会打断当前正在执行的代码
- **软中断和 tasklet**
- **内核抢占**
- **睡眠及 与用户空间的同步**
- **对称多处理器**

**如果一段内核代码在访问一个共享资源期间可以被抢占, 这是个bug**

**两个处理器绝对不能同时访问同一共享数据.**



> **辨认出真正需共享的数据和相应的临界区,才是真正有挑战性的地方**
>
> ==**在编写代码的开始阶段就要设计恰当的锁**==

1. **中断安全代码（interrupt-saft )** : 在中断处理程序中能避免并发访问的安全代码
2. **SMP 安全代码（SMP-safe）:**在对称多处理的机器中能避免并发访问的安全代码, 也意味着抢占安全
3. **抢占安全代码 (preempt-safe）**在内核抢占时能避免并发访问的安全代码



> **内核大多数的数据结构都需要加锁.**
>
> ==**如果有其他执行线程可以访问这些数据, 那么就给这些数据加上某些形式的锁, 全局数据就更需要加锁了**==
>
> ==**一定要给数据加锁, 而不是代码加锁**==





# 死锁

死锁的产生需要一定条件：要有一个或多个执行线程和一个或多个资源，每个线程都在等待其中的一个资源，但所有的资源都已经被占用了。所有线程都在相互等待，但它们永远不会释放已经占有的资源。于是任何线程都无法继续，这便意味着死锁的发生。



- **避免死锁的简单规则:**
  - **按顺序加锁**, 使用嵌套的锁时必须保证以相同的顺序获得锁, 这样可以组织致命拥抱类型的死锁
  - **防止发生饥饿**
  - **不要重复请求同一个锁**
  - **设计应该力求简单**,  越复杂的加锁方案 越有可能造成死锁
- **内核提供防止死锁的测试工具**







# 锁的争用和拓展性

- **锁的争用 ( lock contention ), 或者简称 争用, 是指当锁正在被占用时, 有其他线程试图获得该锁**
  - **说一个锁处于高度争用状态，就是指有多个其他线程在等待获得该锁。**
  - **一个锁处于高度争用状态，就是指有多个其他线程在等待获得该锁。**
  - **由于锁的作用是使程序以串行方式对资源进行访向，所以使用锁无疑会降低系统的性能。**
  - 被高度争用（频繁被持有，或者长时间持有一两者都有就更糕）的锁会成为系统的瓶颈，严重降低系统性能。即使是这样，相比于被几个相互抢夺共享资源的线程撕成碎片，搞得内核崩溃，还是这种同步保护来得更好一点。当然，如果有办法能解决高度争用题，就更好不过了。
- **扩展性 ( scalability  )  是对系统可拓展程度的一个量度**
  - 对于操作系统，我们在谈及可扩展性时就会和大量进程、大量处理器或是大量内存等联系起来.
- **加锁粒度  用来描述 加锁保护的数据规模**
  - **过粗的锁保护大块数据, 比如一个子系统用到的所有的数据结构**
  - **精细的锁保护很小的一块数据, 锁越精细越好**





# 内核同步方法

**Linux提供了一组相当完备的同步方法.**

==**原子操作是其他同步方法的基石**==

==**真正的原子操作需要的是一所有中间结果都正确无误。**==





- **能使用原子操作时, 就不要使用复杂的加锁机制**
- **加锁时间不长, 并且不会睡眠(中断处理程序) , 利用读写自旋锁是最好的选择.**
- **加锁时间很长或则代码在持有锁时有可能睡眠, 那么最好使用信号量来完成**





- ==**内核抢占代码使用自旋锁作为非抢占区域的标记**==

  - ==**如果一个自旋锁被持有，内核便不能进行抢占 ,因为内核抢占和 SMP 面对相同的并发问题**==

    



- ==**锁的选择:**==

  - **自旋锁:**

    - **中断上下文  中 只能使用 自旋锁**
      - **中断上下文中加锁 : 使用自旋锁**
    - **低开销加锁:   优先使用 自旋锁**
    - **短期锁定 : 优先使用 自旋锁**

  - **互斥体**

    - **持有锁的任务需要睡眠 : 使用互斥体**
    - **长期加锁 : 优先使用互斥体**

  - **信号量**

    - **很底层的代码 才需要考虑使用信号量**

  - **完成变量**

    - **`vfork()` 系统调用使用完成变量来唤醒父进程**
    - **完成变量的通用方法是 将完成变量作为数据结构中的一项动态创建**

  - **顺序锁 seq**
  
    - **用于读写共享数据**
    - **在某些场合不能使用原子量的时候**
  
  - **禁止抢占**
  
    - **一般是内核模块持有自旋锁并且访问重要数据时时, 需要禁止抢占**
  
  - 
  
    





## 原子操作



- **原子操作是其他同步方法的基石**
  - ==**原子操作可以保证指令以原子的方式执行,  执行过程不会被打断**==
  - **原子通过把读取和增加变量的行为包含在一个单步中执行, 从而防止了竞争的发生保证了操作结果总是一致的.**
  - **两个原子操作绝不可能并发的访问同一个变量, 加操作也就绝不可能引起竞争**
- **内核提供了两个原子操作接口:**
  - 针对 **整数** 进行操作
  - 针对单 **独的位** 进行操作
  - **Linux支持的所有体系结构上, 都实现了这两组接口, 大多数体系结构也会提供支持原子操作的 ==简单算术指令==**
    - **也可能只提供锁内存总线的指令,  确保了其他改变内存的操作不能同时发生**
- **原子操作通常是内联函数, 往往是通过内嵌汇编指令来实现的**
  - 如果某个函数本来就是原子的，那么它往往会被定义成一个宏。
    - 例如，在大部分体系结构上，读取一个字本身就是一种原子操作，也就是说，==**在对一个字进行写操作期间不可能完成对该字的读取**==。这样，把 `atomic_read()` 定义成一个宏，只须返回 atomic t 类型的整数值就可以了。
- **原子性意味着，或者指令完整地成功执行完，不被打断，或者根本不执行。**
  - **真正的原子操作需要的是, 所有中间结果都正确无误。**
- ==**原子操作只保证原子性, 顺序性通过屏障指令来实施**==





### 原子整数操作

- ==**针对整数的原子操作只能对 `atomic_t` 类型的数据进行处理, 这是个特殊的数据类型**==
  - **原子函数只接收  atomic t 类型的操作数，可以确保:**
    - **原子操作只与这种特殊类型数据一起使用**。
    - **该类型的数据不会被传递给任何非原子函数**
  - 使用 atomic t 类型确保编译器不对相应的值进行访问优化,这点使得原子操作最终接收到正确的内存地址，而不只是一个别名。最后，在不同体系结构上实现原子操作的时候，使用 atomic_t 可以屏蔽其间的差异。atomic_t  类型定义在文件 `< include/linux/types.h >`  中：
    - **使用原子整形的操作需要声明在 `< arch/x86/include/sam/atomic.h >`**

```c
#include < include/linux/types.h >

// 尽管 Linux 支持的所有机器上的整型数据都是 32 位的，但是使用 atomic_t 的代码只能将该类型的数据当做 24 位来用。这个限制完全是因为在 SPARC 体系结构上，原子操作的实现不同于其他体系结构：32 位 n 类型的低 8 位被嵌入了一个锁，因为 SPARC 体系结构对原子操作缺乏指令级的支持，所以只能利用该锁来避免对原子类型数据的并发访问。所以在 SPARC 机器上就只能使用 24 位了。虽然其他机器上的代码完全可以使用全部的 32 位，但在  SPARC 机器上却可能造成一些奇怪和微妙的错误,这简直太不和了。最近，机灵的黑客已经允许 SPARC 提供全 32 位的 atomic_t，这一限制不存在了。

// 32位 使用的锁
typedef struct {
	volatile int counter;
} atomic_t;

// 64位 使用的锁
#ifdef CONFIG_64BIT
typedef struct {
	volatile long counter;
} atomic64_t;
#endif



#include  < arch/x86/include/sam/atomic.h >
//有些体系结构会提供一些只能在该体系结构上使用的额外原子操作方法，但所有的体系结构都能保证内核使用到的所有操作的最小集.
// C 不能保证的原子操作。用于资源计数等。

 /*  atomic_t 成员 初始化  */
#define ATOMIC_INIT(i)	{ (i) } 
	例子:  atomic_t  v;      // 定义v
        atomic_t u = ATOMIC_INIT(0);    // 定义u  并初始化为 0

/* 操作 ,  一般的锁机制 使用 atomic_inc() 和 atomic_dec() 这两个相对轻便的操作即可 */
 atomic_set(&v,4);   /* v =4 (原子的) */
 atomic_add(2,&v);   /* v = v + 2 = 6 (原子的) */

 atomic_inc(&v);   /* v = v+ 1 = 7 (原子的)  ,  自增 1*/
 atomic_dec(&v);   /* v = v - 1 = 6 (原子的) ,  自减 1*/

 int t = atomic_read(&v);    /* 将 v 转换成int 赋值给 t  */
 printk("%d\n", atmoic_read(&v));  // 会打印6  


// 某个实现
static inline int atomic_read(const atomic_t *v)
{
	return v->counter;
}

```

|                32位原子整数操作                 |                        描述                         |
| :---------------------------------------------: | :-------------------------------------------------: |
|             `ATOMIC_INIT (int i )`              |     在声明一个 atomic_t 变量时，将它初始化为 i      |
|         `int atomic_read(atomic_t *v)`          |                 原子地读取整数变量ⅴ                 |
|     `void atomic_set(atomic_t  *v, int t )`     |                 原子地设置 ⅴ 值为 t                 |
|     `void atomic_add(int t, atomic_t  *v )`     |                  原子地给 v 加  t                   |
|     `void atomic_sub(int t, atomic_t  *v )`     |                  原子地给 v 减  t                   |
|    ==**`void atomic_inc(atomic_t  *v )`**==     |                **原子地给 v 加  1**                 |
|    ==**`void atomic_dec(atomic_t  *v )`**==     |                **原子地给 v 减  1**                 |
| `int atomic_sub_and_test( int t, atomic_t *v )` | 原子地从 v 减 t，如果结果等于 0, 返回真；否则返回假 |
| `int atomic_add_negtive( int t, atomic_t *v )`  | 原子地从 v 加 t，如果结果是负数, 返回真；否则返回假 |
|  `int atomic_add_return( int t, atomic_t *v )`  |             原子地给 v 加 t，且返回结果             |
|  `int atomic_sub_return( int t, atomic_t *v )`  |             原子地给 v 减 t，且返回结果             |
|  `int atomic_inc_return( int t, atomic_t *v )`  |             原子地给 v 加 1，且返回结果             |
|  `int atomic_dec_return( int t, atomic_t *v )`  |             原子地给 v 减 1，且返回结果             |
|  ==`int atomic_dec_and_test(  atomic_t *v )`==  | 原子地从 v 减 1, 如果结果等于 0, 返回真；否则返回假 |
|  ==`int atomic_inc_and_test( atomic_t *v )`==   | 原子地从 v 加 1, 如果结果等于 0, 返回真；否则返回假 |



|                  64位原子整数操作                   |                        描述                         |
| :-------------------------------------------------: | :-------------------------------------------------: |
|              `atomic64_INIT (long i )`              |    在声明一个 atomic64_t 变量时，将它初始化为 i     |
|         `int atomic64_read(atomic64_t *v)`          |                 原子地读取整数变量ⅴ                 |
|     `void atomic64_set(atomic64_t  *v, int t )`     |                 原子地设置 ⅴ 值为 t                 |
|     `void atomic64_add(int t, atomic64_t  *v )`     |                  原子地给 v 加  t                   |
|     `void atomic64_sub(int t, atomic64_t  *v )`     |                  原子地给 v 减  t                   |
|    ==**`void atomic64_inc(atomic64_t  *v )`**==     |                **原子地给 v 加  1**                 |
|    ==**`void atomic64_dec(atomic64_t  *v )`**==     |                **原子地给 v 减  1**                 |
| `int atomic64_sub_and_test( int t, atomic64_t *v )` | 原子地从 v 减 t，如果结果等于 0, 返回真；否则返回假 |
| `int atomic64_add_negtive( int t, atomic64_t *v )`  | 原子地从 v 加 t，如果结果是负数, 返回真；否则返回假 |
|  `int atomic64_add_return( int t, atomic64_t *v )`  |             原子地给 v 加 t，且返回结果             |
|  `int atomic64_sub_return( int t, atomic64_t *v )`  |             原子地给 v 减 t，且返回结果             |
|  `int atomic64_inc_return( int t, atomic64_t *v )`  |             原子地给 v 加 1，且返回结果             |
|  `int atomic64_dec_return( int t, atomic64_t *v )`  |             原子地给 v 减 1，且返回结果             |
|  ==`int atomic64_dec_and_test(  atomic64_t *v )`==  | 原子地从 v 减 1, 如果结果等于 0, 返回真；否则返回假 |
|  ==`int atomic64_inc_and_test( atomic64_t *v )`==   | 原子地从 v 加 1, 如果结果等于 0, 返回真；否则返回假 |





### 原子位操作

**除了原子整数操作外，内核也提供了一组针对位这一级数据进行操作的函数.**

**位操作函数是对普通的内存地址进行操作的**

**由于原子位操作是对普通的指针进行的操作，所以不像原子整型对应 atomic_t，这里没有特殊的数据类型。相反，只要指针指向了任何你希望的数据，你就可以对它进行操作.**

```c
#include < arch/x86/include/asm/bitops.h >
/* 它的参数是一个指针和一个位号，
  * 第 0 位是给定地址的最低有效位。
  *    在 32 位机上，第 31 位是给定地址的最高有效位而第 32 位是下一个字的最低有效位。
  *    虽然使用原子位操作在多数情况下是对一个字长的内存进行访问，因而位号应该位于 0~31（在 64 位机器中是 0~63），但是，对位号的范围并没有限制。
 */

unsigned long word = 0 ;
set_bit ( 0, &word);    // 第0 位 被设置 (原子的)
set_bit ( 1, &word);    // 第1 位 被设置 (原子的)
printk("ul\n", word);   // 打印3
clear_bit (1, &word);   // 清空 1 位,  word =1
change_bit (0, &word);  // 翻转第0位的值, 这里他被清空,  word =0

// 原子的设置第0位 并且返回设置前的值, 返回的值是 word=0,  设置之后 word=1
   if(test_and_set_bit(0, &word){
      // 永远不为真 , 不会进来
   }
      
      
内核提供了两个例程用来从指定的位置开始搜索第一个 被设置或未被设置的 位
      int find_first_bit( unsigned long* addr, unsigned int size);  // 第一个被设置的 1
      int find_first_zero_bit( unsigned long* addr, unsigned int size); // 第一个没有被设置的 0
      // 这两个函数中第一个参数是一个指针，第二个参数是要搜索的总位数，返回值分别是第一个被设置的（或没被设置的）位的位号。如果你的搜索范围仅限于一个字，使用 _ffs() 和 ffz() 这两个函数更好，它们只需要给定一个要搜索的地址做参数。
```

|                  原子位操作                  |                        描述                        |
| :------------------------------------------: | :------------------------------------------------: |
|     `void  set_bit(int nr, void* addr)`      |         原子地设置addr 所指对象的第 nr 位          |
|     `void clear_bit(int nr, void*addr)`      |         原子地清空 addr 所指对象的第 nr 位         |
|     `void clange_bit(int nr, void*addr)`     |        原子地翻转 addr  所指对象的第 nr 位         |
|  `int test_and_set_bit(int nr, void*addr)`   | 原子地设置 addr 所指对象的第 nr 位, 并返回原先的值 |
| `int test_and_clear_bit(int nr, void*addr)`  | 原子地清空 addr 所指对象的第 nr 位, 并返回原先的值 |
| `int test_and_change_bit(int nr, void*addr)` | 原子地翻转 addr 所指对象的第 nr 位, 并返回原先的值 |
|      `int test_bit(int nr, void*addr)`       |         原子地返回 addr 所指对象的第 nr 位         |

```c
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/wait.h>
#include <linux/poll.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <asm/atomic.h>
#include <asm/cmpxchg.h>


#define BUFFER_MAX   (64)
#define OK           (0)
#define ERROR        (-1)

struct cdev* gDev;
struct file_operations* gFile;
dev_t devNum;
unsigned int subDevNum = 1;
int reg_major = 232;  //主设备号
int reg_minor = 0;    //次设备号
char buffer[BUFFER_MAX];
static atomic_t can_open = ATOMIC_INIT(1);  // 原子变量 , 会等于1


int hello_open(struct inode* p, struct file* f){
    if( ! atomic_dec_and_test(&can_open)){   // 将can_open减1 等于0,无论是否得到了锁 ,原子操作
       // 下面是没有得到锁的线程所执行的代码
      printk(KERN_INFO "device is busy, hello_open fail"); 
      atomic_inc(&can_open);    // 将can_open +1, 恢复为0的状态  , 原子操作
      return -EBUSY;
    }
    printk(KERN_EMERG "hello_open ok\r\n"); // 会输出到 Linux的模块日志中, 使用 dmesg 命令查看
    return 0;
}

int hello_close(struct inode* inode, struct file* filp){
  atomic_inc(&can_open); 
  printk(KERN_INFO "hello_clsoe ok\r\n");
  return 0;
}


ssize_t  hello_write(struct file*f, const char __user* u,  size_t s, loff_t* l){
    printk(KERN_EMERG "hello_write\r\n");
    int writelen = 0;
    writelen = BUFFER_MAX > s ? s : BUFFER_MAX;
    if(copy_from_user(buffer, u, writelen)){  // 从用户空间读取数据并拷贝到内核空间
      return -EFAULT;
    }
    return writelen;
}


ssize_t hello_read(struct file*f, char __user* u, size_t s, loff_t * l){
    printk(KERN_EMERG "hello_read\r\n");
    int readlen;
    readlen = BUFFER_MAX > s ? s : BUFFER_MAX;
    if(copy_to_user(u, buffer, readlen)){ // 从内核空间读取数据并拷贝到用户空间
       return -EFAULT;
    }
    return readlen;
}
 
 int hello_init(void){
     devNum = MKDEV(reg_major, reg_minor);   //通过一个宏来生成主+次设备号
     if(OK == register_chrdev_region(devNum, subDevNum, "helloworld")){ // 指定设备号注册
         printk(KERN_EMERG "register_chrdev_region ok\n");
     }
     else{
         printk(KERN_EMERG "register_chrdev_region error \n"); 
         return ERROR;
     }
     printk(KERN_EMERG "hello driver init \n");
     gDev = kzalloc(sizeof(struct cdev), GFP_KERNEL);
     gFile = kzalloc(sizeof(struct file_operations), GFP_KERNEL);
    gFile->open = hello_open;
    gFile->read = hello_read;
    gFile->write = hello_write;
    gFile ->owner = THIS_MODULE;
    cdev_init(gDev, gFile);
    cdev_add (gDev, devNum,1);
   
   spin_lock_init(&count_lock);  // 初始化
   
    return 0;
 }

void __exit hello_exit(void){
    cdev_del (gDev);
    unregister_chrdev_region(devNum, subDevNum);
    return ;
}

 module_init(hello_init);   // 声明了驱动的入口函数, 挂载
 module_exit(hello_exit);   // 声明了驱动的出口函数, 卸载
 MODULE_LICENSE("GPL");     // 该源码的声明许可
```









## 自旋锁

**临界区甚至可以跨越多个函数**

- **同步方法 : 自旋锁,   自旋锁最多只能被一个可执行线程持有.** 
  - **锁已经被其他执行线程持有时:**
    - 那么该线程就会一直进行 ==**忙循环, 旋转, 等待**== 锁重新可用。
  - **要是锁没被争用:**
    - **请求锁的执行线程便能立刻得到它，继续执行**
- **在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区**
- **同一个锁可以用在多个位置，例如，对于给定数据的所有访问都可以得到保护和同步。**
- **被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间）,**
  - **也可以使请求线程睡眠, 直到锁重新可用时 再唤醒它**
    - **但是有两次明显的上下文切换的耗时.**
- **持有自旋锁的时间最好小于完成两次上下文切换的耗时**
  - ==**自旋锁不应该被长时间持有。**==
- **使用自旋锁的初衷：在短期间内进行轻量级加锁**
- ==**自旋锁的实现和体系结构密切相关, 代码往往是通过汇编实现, 定义在 `<arck/x86/include/asm/spinlock.h>`**==
- **保证临界区代码 简短 高效**

> - 自旋锁 spinlock 的特点:
>   - spinlock 是一种死等的锁机制
>   - semaphore 可以允许多个执行单元进入, 但 spinlock不行 , 一次只能有一个执行单元获取锁并进入临界区, 其他执行单元都是在门口不断的死等
>   - 执行时间短, 由于spinlock **死等** 这种特性, 如果临界区执行时间太长, 那么不断在临界区门口死等的 那些执行单元是多么浪费 CPU 啊
>   - **可以在中断上下文中执行. 由于不睡眠, 因此spinlock 可以在中断上下文中使用.**

==**绝对不可以在 自旋锁的临界区内 调用睡眠函数 (sleep() 之类的)**==

==**自旋锁不可递归**==

**单核处理器不会加入自旋锁, 如果禁止内核抢占 ,那么编译时 自旋锁会被完全剔出内核**

==**自旋锁可以使用在中断处理程序中, 但是要在获取锁之前 要禁止本地中断**==

```c
#include <arck/x86/include/asm/spinlock.h>  //自旋锁的实现
#include <include/linux/spinlock_types.h>  //自旋锁的头文件

typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;


基本的使用形式如下:
  DEFINE_SPINLOCK(mr_lock);   // 静态初始化,  mr_lock 是 static spinlock_t mr_lock;
  spin_lock(&mr_lock);
  /* 这个中间就是临界区 代码..  */
  spin_unlock(&mr_lock);


spinlock_t  count_lock;  // 自旋锁类型和值

// 64位 或32位
#ifdef CONFIG_64BIT
	unsigned long flags;
#else
	unsigned int flags;
#endif


// spinlock系列函数
void spin_lock_init(&count_lock);  // 初始化锁
void spin_is_locked(spinlock_t* lcok); //如果指定的锁当前被占用 , 占用返回非0, 否则返回0
int  spin_trylock(spinlock_t* lock);  // 尝试获取锁, 如果成功返回非0值, 否则返回零值

// 普通代码和 tasklet 可以使用普通锁 ,tasklet则是在不同种类共享一个数据时 才需要上锁,但不用禁止下半部
void spin_lock(spinlock_t* lock);  // 获取指定的锁
void spin_unlokc(spinlock_t* lock); // 释放锁

//中断可以抢占,中断上下文代码, 可以抢占进程上下文代码, 所以都要做好保护
void spin_lock_irq(spinlock_t* lock); // 无条件禁止中断, 并且上锁
void spin_unlock_irq(spinlock_t* lock); // 无条件的在解锁时 激活本地中断

void spin_lock_irqsave(&lock, flags);  // 保存本地中断状态,禁止中断 并 获取锁
void spin_unlock_irqrestore(&lock, flags); // 释放指定的锁, 并让本地中断恢复到以前状态

// 由于下半部可以抢占进程上下文的代码,所以当下半部和进程上下文共享数据时, 必须对进程上下文的共享数据进行保护.
void spin_lock_bh(spinlock_t* lcok);  // 获取指定锁,同时禁止所有下半部的执行 ,与下半部配合使用
void spin_unlock_bh(spinlock_t* lcok);  // 释放指定锁,同时激活所有下半部的执行 ,与下半部配合使用






// 内核提供 禁止中断 同时请求锁的 接口
 DEFINE_SPINLOCK(mr_lock);
 unsigned long  flags;
 spin_lock_irqsave(&mr_lock, flags); // 保存中断的当前状态,并禁止本地中断,然后获取指定的锁,  
                                    // 如果是单核处理器,那么仍会关闭中断,禁止中断处理程序访问共享数据
 /* 临界区代码 */
 spin_unlock_irqrestore(&mr_lock, flags); // 解除指定的锁,中断恢复到禁止中断之前


```

```c
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/wait.h>
#include <linux/poll.h>
#include <linux/sched.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/spinlock_types.h>


#define BUFFER_MAX   (64)
#define OK           (0)
#define ERROR        (-1)

struct cdev* gDev;
struct file_operations* gFile;
dev_t devNum;
unsigned int subDevNum = 1;
int reg_major = 232;  //主设备号
int reg_minor = 0;    //次设备号
char buffer[BUFFER_MAX];

spinlock_t  count_lock;  // 自旋锁
int open_count = 0;


int hello_open(struct inode* p, struct file* f){
	spin_lock(&count_lock);
  if(open_count >= 1){
    spin_unlock(&count_lock);
    printk(KERN_INFO "device is busy, hello_open fail"); 
    return -EBUSY;
    }
  open_count++;
  spin_unlock(&count_lock);
    printk(KERN_EMERG "hello_open ok\r\n"); // 会输出到 Linux的模块日志中, 使用 dmesg 命令查看
    return 0;
}

int hello_close(struct inode* inode, struct file* filp){
	if(open_count != 1){
    printk(KERN_INFO "something wrong , hello_close fail");
    return -EFAULT;
  }
  open_count--;
  printk(KERN_INFO "hello_clsoe ok\r\n");
  return 0;
}


ssize_t  hello_write(struct file*f, const char __user* u,  size_t s, loff_t* l){
    printk(KERN_EMERG "hello_write\r\n");
    int writelen = 0;
    writelen = BUFFER_MAX > s ? s : BUFFER_MAX;
    if(copy_from_user(buffer, u, writelen)){  // 从用户空间读取数据并拷贝到内核空间
      return -EFAULT;
    }
    return writelen;
}


ssize_t hello_read(struct file*f, char __user* u, size_t s, loff_t * l){
    printk(KERN_EMERG "hello_read\r\n");
    int readlen;
    readlen = BUFFER_MAX > s ? s : BUFFER_MAX;
    if(copy_to_user(u, buffer, readlen)){ // 从内核空间读取数据并拷贝到用户空间
       return -EFAULT;
    }
    return readlen;
}
 
 int hello_init(void){
     devNum = MKDEV(reg_major, reg_minor);   //通过一个宏来生成主+次设备号
     if(OK == register_chrdev_region(devNum, subDevNum, "helloworld")){ // 指定设备号注册
         printk(KERN_EMERG "register_chrdev_region ok\n");
     }
     else{
         printk(KERN_EMERG "register_chrdev_region error \n"); 
         return ERROR;
     }
     printk(KERN_EMERG "hello driver init \n");
     gDev = kzalloc(sizeof(struct cdev), GFP_KERNEL);
     gFile = kzalloc(sizeof(struct file_operations), GFP_KERNEL);
    gFile->open = hello_open;
    gFile->read = hello_read;
    gFile->write = hello_write;
    gFile ->owner = THIS_MODULE;
    cdev_init(gDev, gFile);
    cdev_add (gDev, devNum,1);
   
    spin_lock_init(&count_lock);  // 初始化
    return 0;
 }

void __exit hello_exit(void){
    cdev_del (gDev);
    unregister_chrdev_region(devNum, subDevNum);
    return ;
}

 module_init(hello_init);   // 声明了驱动的入口函数, 挂载
 module_exit(hello_exit);   // 声明了驱动的出口函数, 卸载
 MODULE_LICENSE("GPL");     // 该源码的声明许可
```



## 自旋锁调试

```c
配置选项
   CONFIG_DEBUG_SPINLOCK   为了使用自旋锁的代码加入的调试手段, 内核会检查是否使用了为初始化的锁,是否在没有加锁的情况下进行了解锁操作,调试内核代码时 , 应该总是激活该选项.
   CONFIG_DEBUG_LOCK_ALLOC   全程调试锁.
   
```



## 读写自旋锁

**读写自旋锁为读和写分别提供了不同的锁**

==**读写自旋锁可以用在中断处理程序中, 但是要使用 中断禁止的 读写自旋锁**==

如果加锁死减不长, 并且不会睡眠(中断处理程序) , 利用自旋锁死最好的选择.

```c
#include </include/linux/rwlock.h>

typedef struct {
	arch_rwlock_t raw_lock;
#ifdef CONFIG_GENERIC_LOCKBREAK
	unsigned int break_lock;
#endif
#ifdef CONFIG_DEBUG_SPINLOCK
	unsigned int magic, owner_cpu;
	void *owner;
#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
	struct lockdep_map dep_map;
#endif
} rwlock_t;

读写锁使用方法类似于普通自旋锁
  DEFINE_RWLOCK(mr_rwlock);  // 静态初始化,  mr_rwlock 是 static rwlock_t mr_rwlock;

// 读
  read_lock (&mr_rwlock);
  /* 临界区 只读 */
  read_unlock(&mr_rwlock);

//写
  write_lock(&mr_rwlock);
  /* 临界区 读写 */
  write_unlock(&mr_rwlock);


读写锁之间 不能升级, 否则会死锁,  就会是调用读锁后 紧接着调用了写锁.
读锁递归调用是安全的.
  
 int write_trylock(&mr_rwlock); // 试图获得指定的写锁, 如果写锁不可用, 就返回非0值
 int rwlock_init(&mr_rwlock); // 初始化指定的 rwlock_t , 动态
  
 int read_lock(&mr_rwlock);  // 获得指定读锁
 int read_unlock(&mr_rwlock);// 释放指定读锁

 int read_lock_irq(&mr_rwlock);  // 禁止本地中断并 获得指定读锁
 int read_unlock_irq(&mr_rwlock);// 释放指定读锁 并激活本地中断

 int read_lock_irqsave(&mr_rwlock,flags);  // 存储本地中断的当前状态, 禁止本地中断并 获得指定读锁
 int read_unlock_irqrestore(&mr_rwlock,flags);//释放指定的读锁并将本地中断恢复到指定的前状态

 int read_lock_bh(&mr_rwlock);  // 获取指定读锁,同时禁止所有下半部的执行 ,与下半部配合使用
 int read_unlock_bh(&mr_rwlock); // 释放指定读锁,同时激活所有下半部的执行 ,与下半部配合使用

 int write_lock(&mr_rwlock);// 获得指写锁
 int write_unlock(&mr_rwlock);// 释放指定写锁

 int write_lock_irq(&mr_rwlock);// 禁止本地中断并 获得指定写锁
 int write_unlock_irq(&mr_rwlock);// 释放指定写锁 并激活本地中断

 int write_lock_irqsave(&mr_rwlock,flags);  // 存储本地中断的当前状态, 禁止本地中断并 获得指定写锁
 int write_unlock_irqrestore(&mr_rwlock,flags);//释放指定的写锁并将本地中断恢复到指定的前状态

 int write_lock_bh(&mr_rwlock);// 获取指定写锁,同时禁止所有下半部的执行 ,与下半部配合使用
 int write_unlock_bh(&mr_rwlock); // 释放指定写锁,同时激活所有下半部的执行 ,与下半部配合使用


```



## 信号量

- **Linux 中的信号量是一种睡锁**。
  - 如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒，并获得该信号量。
- ==**信号量比 自旋锁提供了更好的处理器利用率, 但是却比自旋锁有更大的开销 (进程上下文切换)**==
- **信号量的睡眠特性:  信号量和自旋锁的差异**
  - **锁适合被长时间持有**
  - 由于执行线程在锁被争用时会睡眠，**所以只能在  进程上下文中 才能获取信号量锁**，因为在中断上下文中是不能进行调度的。
  - 持有信号量的线程可以睡眠, 也不会造成死锁, 但是睡眠的线程未来要唤醒和执行
  - **占用信号量时 不能占用自旋锁,  因为自旋锁不允许睡眠**
  - **信号量不会禁止内核抢占, 所以持有信号量的代码可以被抢占.**
- ==**信号量同时允许任意数量的持有者, 也就是使用者数量, 在声明信号时指定**==
  - **计数等于1 就是互斥信号量, 计数大于1 就是计数信号量**

> - 信号量 semaphore 的特点:
>   - 允许进程和进程之间的同步
>   - 允许有多个进程进入临界区代码执行
>   - 进程获取不到信号量锁会陷入休眠, 并让出CPU
>   - **被信号量锁保护的临界区代码允许睡眠**
>   - 本质是基于进程调度器, UP(单核CPU) 和 SMP(多核CPU)下的实现无差异
>   - **不支持进程和中断之间的同步,  中断上下文是不会发生睡眠的**

```c
down(); 测试, 对信号量计数 减1 来请求一个信号量, 如果结果等于0 或大于0, 获得信号量锁, 进入临界区, 否则睡眠
up(); 增加, 释放信号量, 会增加 信号量计数
  
#include  <arch/x86/include/asm/semaphore.h>

struct semaphore {   //信号量结构体,   不要直接访问这个结构体的内的任何成员
	spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};


struct  semaphore  sem;
int  val = 1;
// 信号量方法表
void sema_init( &sem,  val);  // 以指定的计数值初始化 动态创建的信号量
void init_MUTEX( &sem );         // 以计数值为1 初始化 动态创建的信号量
void init_MUTEX_LOCKED( &sem );  // 以计数值为0 初始化 动态创建的信号量

int  down_interruptible(&sem); 
/* 尝试获取指定信号量, 没抢到会进入睡眠,但却会响应其他信号, 当前进程进入 TASK_INTERRUPTIBLE状态,
 * 如果收到了 其他信号(如 SIGINIT) 导致被唤醒 则会返回一个 -EINTR 错误,  成功拿到信号量 会返回0
 */

void down(&sem);
/* 尝试获取指定信号量, 没抢到会进入睡眠,但不会响应其他信号, 当前进程进入 TASK_UNINTERRUPTIBLE状态,
 * 直到成功拿到信号量 才会返回
 */

int  down_trylock(&sem);  // 尝试获取指定的信号量, 如果没拿到 就立即返回一个非0值, 成功返回0
void up(&sem);  //释放指定的信号量, 如果睡眠队列不为空, 则唤醒其中一个任务, 而且是按照顺序来获取的




1. 创建和初始化信号量
  静态的:
	  struct  semaphore  name; 
  	int count = 1;  // 二值信号量
	  sema_init(&name, count);  // 静态初始化声明信号量, name是信号量变量名, count 是信号量的使用数量
  静态的第二种方法:
    #define DECLARE_MUTEX (name);   // name 是互斥信号量
  动态的: 
    sema_init( &name, count); //动态 初始化 name信号量 , count 是信号量的使用数量
    #define init_MUTEX(sem)		sema_init(sem, 1)  //简化的宏函数

2. 使用信号量
  static  DECLARE_MUTEX (mr_sem);   // mr_sem 是静态的 struct semaphore 类型 , 并且完成了初始化 1
  // 尝试获取信号量
 int ret = 0;
 while ( (ret = down_interruptible(&mr_sem)))   // 0则抢到锁, 非0 则有问题
      if( ret == -EINTR){
        // 处理信号 ,然后继续抢锁.
        ret =0;
        continue;
      }    
 /*  这里就是已经拿到锁了,  执行临界区代码 */
up(&mr_sem) ;  // 释放信号量
```



## 读写信号量



```c
#include <include/linux/rwsem-spinlock.h>
#include <linux/rwsem.h>

// 读写信号量数据结构
struct rw_semaphore {
	__s32			activity;
	spinlock_t		wait_lock;
	struct list_head	wait_list;
};

读写信号量都是互斥信号量, 也就是说 count 引用计数为1, 读者不限制, 写者 却只有一个.
所有的读写信号量 的睡眠 都不会被信号打断
  
  static DECLARE_RWSEM(mr_rwsem);  // 静态初始化,  mr_rwsem 是 static rw_semaphore mr_rwsem;
  void down_read(&mr_rwsem); // 试图获取信号量用于读, 睡眠到获得锁为止, 不会被信号打断唤醒
  void up_read(&mr_rwsem);   // 释放读信号量
 
  void down_write(&mr_rwsem);// 试图获取信号量用于写, 睡眠到获得锁为止, 不会被信号打断唤醒
  void up_write(&mr_rwsem);  // 释放写信号量
  
  int down_read_trylock(&mr_rwsem);  // 尝试获取读锁, 成功返回 非0,  失败返回0
  int down_write_trylock(&mr_rwsem); // 尝试获取写锁, 成功返回 非0,  失败返回0

  void downgrade_write(&mr_rwsem);  //动态的将 写锁 转换为读锁.


  创建静态声明的 读写信号量
    static  DECLARE_RWSEM(name);        // name 就是读写信号量名
  创建动态声明并初始化的的 读写信号量
     struct rw_semaphore name;
    init_rwsem(&name);   // 初始化
```



## 互斥体

**互斥体就是简化版的信号量, 限制更强, 使用更高效和简单, 但是使用场景更加受限**

- 互斥体限制:
  - 任何时刻只能有一个任务持有 mutex , 也就是说 使用计数为1
  - 执行上锁的线程 在同一个上下文也要执行解锁
  - 不可以递归上锁和解锁
  - ==**当持有一个 mutex 的时候, 进程不可以退出**==
  - ==**mutex 不可以在 中断或下半部中使用**==
  - **mutex 只能通过官方 API 管理：它只能使用内核提供的方法初始化，不可被拷贝、手动初始化或者重复初始化。**

**互斥体 指的就是 任何可以睡眠的强制互斥锁**

==**通过开启 特殊的调试模式, 内核可以采用编程方式检查和警告任何践踏其约束法则的不老实行为**==

```c

DEFINE_MUTEX(mutex);   // mutex

void mutex_init(&mutex);// 动态初始化

void mutex_lock(&mutex); // 锁定, 如果不可锁定 则睡眠
/* 临界区 */
void mutex_unlock(&mutex); // 解锁

void mutex_trylock(&mutex); // 试图获取指定的mutex, 成功返回1, 否则 没有拿到锁就返回 0
void mutex_is_locked(&mutex);  // 如果锁已经被 占用, 则返回1,  否则返回0




通过开启 特殊的调试模式, 内核可以采用编程方式检查和警告任何践踏其约束法则的不老实行为. 
    就是内核配置选项 CONFIG_DEBUG_MUTEXES
```





## 完成变量

**如果在内核中一个任务需要发出信号通知另一任务发生了某个特定事件，利用完成变量是使两个任务得以同步的简单方法。**

**完成变量仅仅提供了代替信号量的一个简单的解决方法.**

**完成变量的通用方法是 将完成变量作为数据结构中的一项动态创建**

```c
#include < include/linux/completion.h >

typedef struct __wait_queue_head {
	spinlock_t lock;
	struct list_head task_list;
} __wait_queue_head ;

//完成变量结构体
struct completion {
	unsigned int done;
	wait_queue_head_t wait;  
};


静态初始化:
	DECLARE_COMPLETION(mr_comp); // 会创建 struct completion mr_comp,  并完成初始化
动态初始化:
	struct completion mr_comp;
	init_completion(&mr_comp);   // 动态初始化.



void wait_for_completion(struct completion *); // 等待指定的完成变量接收信号, 进入阻塞状态
void complete(struct completion *);  // 发信号唤醒任何等待任务
```



## BKL大内核锁

**BKL是一个全局自旋锁, 使用它主要是为了方便实现从 Linux 最初的 SMP 过渡到细粒度加锁机制.**

**新代码不允许使用BKL**

- BKL特性:
  - **持有BKL锁时可睡眠, 但当前任务无法调度时, 所加的锁 会自动被丢弃, 当任务被重新调度时, 锁又会自动获得**
  - **BKL是递归锁**
  - **BKL只可以用在进程上下文中**

```c
BKL是个全局锁 , 但是单核处理器下 不会执行实际的加锁
  
kernel_locked();	  // 检测锁 是否被持有, 被持有 则返回非0,  持有则返回 0

lock_kernel();  // 加锁
/*  临界区
 *  不会死锁, 但是这里的数据在睡眠的时候无法得到保证, 所以这个临界区内 绝不可以睡眠
 *  持有锁的时候, 会禁止内核抢占
 */
unlock_kernel();  // 解锁
```



## 顺序锁

**顺序锁 通常简称 seq锁**

**用于读写共享数据**

实现这种锁主要依靠一个序列计数器。当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取的序列号值相同，说明在读操作进行的过程中没有被写操作打断过。此外，如果读取的值是偶数，那么就表明写操作没有发生（要明白因为锁的初值是 0, 所以写锁会使值成奇数，释放的时变成偶数）。

- **适用锁的时机**
  - 你的数据存在很多读者。
  - 你的数据写者很少。
  - 虽然写者很少，但是你希望写优先于读，而且不允许读者让写者饥饿。
  - 你的数据很简单，如简单结构，甚至是简单的整型, 在某些场合，你是不能使用原子量的

```c
#include < include/linux/seqlock.h >

// 顺序锁 数据结构
typedef struct {
	unsigned sequence;
	spinlock_t lock;
} seqlock_t;   
 

//定义一个seq锁
	seqlock_t mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);

// 写锁的方法,  写操作会插队到读操作的最前面
	write_seqlock(&mr_seq_lock);
	/* 写锁 被获取 */
	write_sequnlock(&mr_seq_lock);

// 读锁的方法
	unsigned long seq;
	do{
      seq = read_seqbegin(&mr_seq_lock);
      /* 读这里的数据 */
  } while( read_seqretry(&mr_seq_lock, seq));  // 这里会检测




// 范例 , jiffies 系统启动以来的时钟节拍累计 
// 获取
u64 get_jiffies_64(void){
{
	unsigned long seq;
	u64 ret;
	do {
		seq = read_seqbegin(&xtime_lock);
		ret = jiffies_64;
	} while (read_seqretry(&xtime_lock, seq));
	return ret;
}
// 定时器中断更新 jiffies的值, 需要写锁
  write_seqlock(&xtime_lock);
  jiffies_64 += 1;
  write_sequnlock(&xtime_lock);
```



## 禁止抢占

- **内核是抢占性的,内核中的进程在任何时刻都可能停下来以便另一个具有更高优先权的进程运行**
  - **一个任务与被抢占的任务可能会在同一个临界区内运行**
    - ==**为了避免这种情况，内核抢占代码使用自旋锁作为非抢占区域的标记**==
      - ==**如果一个自旋锁被持有，内核便不能进行抢占 ,因为内核抢占和 SMP 面对相同的并发问题**==
        - 并且内核已经是 SMP 安全的（SMP-safe），所以，这种简单的变化使得内核也是抢占安全的（preempt-safe）

```c
#include < include/linux/preempt.h >
preempt_disable();  //增加抢占计数值,从而禁止内核抢占.  可以嵌套调用
preempt_enable();   //减少抢占计数值,并但该值降为0时 检查和执行被挂起的需要调度的任务, 可以嵌套调用
preempt_enable_no_resched();  // 激活内核抢占 但不再检查任何被挂起需要重新调度的任务
preempt_count() ;      // 返回抢占计数

通过 get_cpu()  可以获得处理器编号. 但是在该函数处理器号前 会先关闭内核抢占
  {
     int cpu = get_cpu();  // 禁止内核抢占, 并将cpu设置为当前处理器.
     // 对每个处理器的数据进行操作 
     // 在给赋予内核抢占性,  cpu可改变 故它不再有效
     put_cpu();
  }
```





## 顺序和屏障

**处理 多处理器之间或硬件设备之间的同步问题时, 在代码中以指定顺序发出读内存(读入) 或写内存(存储) 指令.**

**硬件交互时 时常需要确保 一个给定的读操作发生在其他写操作之前**

==**确保顺序的指令 称作屏障, 主要是针对 编译器 来要求它不要对代码的静态执行顺序进行重新排序**==

**处理器和编译器绝对不会对全局变量 的代码做重新排序**

```c
// 在排序能力最弱的处理器上, 使用恰当的内存屏障, 这样代码才能在编译时针对体系结构进行优化

mb();  // 阻止跨越屏障的入和存储动作重新排序

// 通用读屏障
rmb();  // 阻止跨越屏障的载入动作发生重新排序, 从内存读
read_barrier_depends();  //阻止跨越屏障的具有数据依赖关系的载入动作重排序, 比rmb效率高.

// 通用写屏障
wmb();  // 阻止跨越屏障的存储动作发生重新排序, 写内存写

// 单核(UP) 编译器屏障 和 多核(SMP) 内存屏障
smp_rmb();  // 在 SMP 上提供 mb() 功能，在 UP 上提供 barrier() 功能
smp_read_barrier_depends(); //在 SMP上提供 read_barrier_ depends()功能，在UP上提供 barrier ()功能
smp_wmb(); // 在 SMP 上提供 wmb() 功能，在 UP 上提供 barrier() 功能
smp_mb();  // 在 SMP 上提供 mb() 功能，在 UP 上提供 barrier() 功能
barrier();  // 阻止编译器 跨屏障对载入或存储操作进行优化
```



