# 正则表达式

**正则表达式**  **`就是处理字串的方法，他是以行 为单位来进行字串的处理行为， 正则表达式通过一些特殊符号的辅助，可以让使用者轻易的达到“搜寻/删除/取代”某特定字串的处理程序!`**

**正则表达式 分为`基础正则表达式`和 `延伸正则表达式` ,延伸正则表达式可以作为群组字串的处理.**



## 基础正则表达式

*正则表达式是处理字串的一种表示方式，对字符排序有影响的语系数据就会对正则 表达式的结果有影响 .*

**正则表达式也需要支持工具程序来辅助才行** 



#### 语系对正则表达式的影响

**使用正则表 达式时，需要特别留意当时环境的语系.**

下面所有的正则表达式都符合 **`POSIX 标准`**, 需要使用 **`LANG=C`** 语系数据来进行.(**`不可以舍弃** [ ] **方括号`**)

| 特殊符號   | 代表意義                                                     |
| ---------- | ------------------------------------------------------------ |
| [:alnum:]  | 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z                 |
| [:alpha:]  | 代表任何英文大小写字符，亦即 A-Z, a-z                        |
| [:blank:]  | 代表空白键与 [Tab] 按键两者                                  |
| [:cntrl:]  | 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等     |
| [:digit:]  | 代表数字而已，亦即 0-9                                       |
| [:graph:]  | 除了空白字符 (空白键与 [Tab] 按键) 外的其他所有按键          |
| [:lower:]  | 代表小写字符，亦即 a-z                                       |
| [:print:]  | 代表任何可以被打印出来的字符                                 |
| [:punct:]  | 代表标点符号 (punctuation symbol)，亦即:" ' ? ! ; : # $...   |
| [:upper:]  | 代表大写字符，亦即 A-Z                                       |
| [:space:]  | 任何会产生空白的字符，包括空白键, [Tab], CR 等等             |
| [:xdigit:] | 代表 16 进位的数字类型，因此包括: 0-9, A-F, a-f 的数字与字符 |



#### grep 的一些进阶选项 (正则表达式)

**grep 在数据中查寻一个字串时，是以 "整行" 为 单位来进行数据的摘取的 **

```bash
$gerp  [-A] [-B] [--color=auto]  '搜寻字串‘ filename
$grep  [-acinv] [--color=auto] '搜寻字串'  filename
选项与参数:
-a   :将 binary 文件以 text 文件的方式搜寻数据
-c   :计算找到 '搜寻字串' 的次数
-i   :忽略大小写的不同，所以大小写视为相同, 默认是区分大小写的.
-n   :顺便输出行号
-v   :反向选择，亦即显示出没有 '搜寻字串' 内容的那一行!

 -A :后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来;
 -B :后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来;
 --color=auto 可将正确的那个撷取数据列出颜色


范例一:用 dmesg 列出核心讯息，再以 grep 找出内含 intel 那行并上色.
$dmesg | grep --color=auto 'intel'     #dmesg 会列出核心产生的讯息,包括硬件侦测流程也会显示出来
输出:
[    0.507864] intel_idle: does not run on family 6 model 158
[    3.928920] snd_intel8x0 0000:00:1f.4: enable Parallels VM optimization
[    4.294938] snd_intel8x0 0000:00:1f.4: intel8x0_measure_ac97_clock: measured 51555 usecs (2548 samples)
[    4.294942] snd_intel8x0 0000:00:1f.4: clocking to 46618


范例三:承上题，在关键字所在行的前两行与后三行也一起捉出来显示
$dmesg | grep -B2 -A3 --color=auto 'intel'
输出:
[    0.507054] Console: switching to colour frame buffer device 128x48
[    0.507855] fb0: EFI VGA frame buffer device
[    0.507864] intel_idle: does not run on family 6 model 158
/*....中间部分省略*/
[    4.294942] snd_intel8x0 0000:00:1f.4: clocking to 46618
[    6.756875] floppy0: no floppy controllers found
[    6.756915] work still pending
[    6.889807] type=1305 audit(1572056014.859:4): audit_pid=733 old=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:auditd_t:s0 res=1
```



#### 基础正则表达式练习

```bash
利用中括号 [] 来搜寻集合字符,  [^] 表示反向选择,
$grep  -n 't[ae]st'  reg.txt
		#会输出行号,并且会寻找 'test tast ' 这两种串
		# 无论方括号内有多少个字符,都算一个位置,相当于是一个集合.

$grep -n '[^g]oo'  reg.txt
	  #反向选择, 会检索文件内 oo 的字符串, 并且把 oo前面是g 的行拿掉.
	  	#但是, 如果该行出现了 'goooo' 这种的字串,还是会被选择出现的.因为它后面的内容符合条件.
	  	
$grep -n '[^a-z]oo'   reg.txt
		#oo前面不允许出现小写英文字符, 但是只有ASCII 才可以这么写(小写连续的).

grep -n '[^[:lower:]]oo' reg.txt
		#整段表示, 不要输出 oo 前面有小写字符的字符串行,也包括 oo 前面什么都没有的串行.
    #  [:lower:] 代表小写字符，亦即 a-z (可以避免编码问题)  , [^] 表示反向选择(排除项)



行首与行尾字符 ^ $   (这里字符不在[] 方括号里了,要注意,意义不同)
$grep -n '^the' reg.txt
		#只显示 'the' 在行首 出现的行.   ' ^ ' 表示行首

$gerp -n '^[a-z]'  reg.txt
		#只显示行首 是小写字符的行.
		# 可以这样代替 : 
					$ grep -n '^[[:lower:]]'  reg.txt

$grep -n '^[^[:alpha:]]'  reg.txt
		#只显示行首 不是英文字母 开头的行,(无论大小写),   [:alpha:] 表示所有英文字母并且无论大小写.
		# 可以这样代替 : 
					$grep -n '^[^a-z,A-Z]' reg.txt

$grep -n '\.$' reg.txt
		#只显示 行尾 是 . 结尾的行.  因为小数点是有特殊意义的,所以需要转义字符来进行处理.
			#但是要注意文本的 断行尾, unix 和dos 是不同的,需要进行转换,否则输出不正确($dos2unix)

$grep -n '^$' reg.txt
		# 只显示空行, 就是什么数据都没有的行,没有空格也没有[tab],(可以出现换行符 \n )

$grep -v '^$' /etc/rsyslog.conf | grep -v '^#'
		#去除空行, 去除行首为 # 符号的行.  -v 参数表示的是不要后面参数的行.


任意一个字符 . 与重复字符 *   ,不在[]方括号内
	. 代表 "一定有一个任意字符" 的意思      ( .* 代表任意字符)
	* 代表 "重复前一个字符,0到无数次" 的意思,( 前面必须有一个牺牲字符)
$grep -n  'g..d' reg.txt 
		 # g和d 之间必须有两个任意字符, 是必须有两个字符, 不可以多, 也不可以少

$grep -n 'goo*g' reg.txt
		# 寻找的是 : 串两边都有g 并且中间至少有一个o 或多个 o, *前面的第一个o 是牺牲字符.
		#  牺牲字符代表了两个东西,一个是字符o,另一个就是空字符. (这两者都可以无限多)
		# 如果搜索条件给出 'o*' 的话, 那么 reg.txt 文件中, 所有的内容全部都会打印出来.
		#  毕竟 * 代表的是 0个 或无数个, 那么就算这行没有o 也会被选中的.

$grep -n '^g.*g$' reg.txt 
		#寻找的是 以g 为行首, g为行尾, 无论中间字符是什么的行. 只要这行开头结尾都是g 就可以.
		
$grep -n '[0-9][0-9]*' reg.txt
		#找出 有任意数字的 行.  只要该行出现数字 那么就选中. 第二个数字就是牺牲字符.
			#和下面效果一样
				$rep -n '[0-9]' reg.txt

$ls /etc -h | grep '^[^d]' |cut -d ' ' -f9  | grep '^a.*' -n
			#寻找 /etc 下所有的 以a 开头的文件名. (不可以出现目录)
	

限定连续 RE 字符范围 {n1,n2}
  {} 因为在 shell下,这两个尖括号都有特殊意义,所以需要使用\转义字符来让他失去特殊意义才行.
  		就算脚本也要有 \转义字符 ,不可以省略.
$grep  -n 'o\{2\}'  reg.txt
			#寻找 拥有 2个以及2个以上 相连的 o 的串, 选中该行.
			# 也可以这么写, 效果相同
						$grep -n 'go\{2,\}g'  reg.txt

$grep -n 'go\{2,5\}g'  reg.txt
			#寻找 g 开头和结尾 并且中间有 2到5 个 o 的行.严格限定了 o 出现的个数. 
```



#### sed 工具

**`sed`** 本身也是一个管道命令, 可以分析 `stdin`, 还可以对`数据`进行**`替换,删除,新增,摘取`** 等特定功能.

```bash
$sed  [-nefr]  [动作] [文件(可有可无)]
选项与参数:
-n  :使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。
	   但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行(或者动作)才会被列出来。
-e  :直接在命令行界面上进行 sed 的动作编辑;
-f  :直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作;
-r  :sed 的动作支持的是延伸型正则表达式的语法。(默认是基础正则表达式语法)
-i  :直接修改读取的文件内容，而不是由屏幕输出。

动作:  [n1, [n2]] function          #动作必须用两个 单引号  括住.
n1,n2   :不见得会存在,一般代表 “选择进行动作的行数”, 
				举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ”
	function  有下面的参数:
         a :新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)~,使用 \ 来新增多行.
         c :替换， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行!
         d :删除，因为是删除啊，所以 d 后面通常不接参数,只是删除  n1-n2的行;
         i :插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行);
         p :打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行~
         s :取代，可以直接进行取代的工作哩!通常这个 s 的动作可以搭配正则表达式!
					  例如 1,20s/old/new/g 就是啦!

范例:  将/etc/passwd 的内容列出来,并打印行号, 同时将 2-5行 删除
$nl /etc/passwd | sed '2,5d'          #nl会读取文件,并加入行号之后进行输出
		如果将 第二行之后的所有行都删除的话,可以使用$ 符号来表示最后一行(区别于正则)
				$nl  /etc/passwd  | sed '3,$d'

范例: 在第二行之后加上 'drink tea?' 字符.
$nl  /etc/passwd |  sed '2a drink tea?'	   #2a表示的是行和动作,后面的是新插入的字符串.


范例: 在第二行之后加上两行 'drink tea?' 字符.
n$l   /etc/passwd | sed  '2a drink tea?\
> drink tea?'				#前面的 > 是系统默认别的, \后面接的是回车键, 只要有\ 就代表多行插入.


范例: 将第2-5行的内容替换成 'No 2-5 number'
$nl /etc/passwd | sed '2,5c No 2-5 number'

范例: 输出 11-20 行的内容.  -n 参数很重要.
$nl /etc/passwd | sed -n '11,20p'



范例:  (替换操作和 vim 的操作相仿,  sed 'n1,n2s/old/new/g')
摘取IP的那一行数据:
	$ifconfig eth0 | grep 'inet '      #inet 后面有个空格,这是要注意的
将IP前面的数据予以删除:
	$ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g'
				#后面的 s 	取代, ^.*inet 正则表达式:选中行首无限个任意字符和inet,然后停止替换成空值
只留下IP ,其余内容全部删除.
$ifconfig eth0 | grep 'inet ' | sed 's/^.*inet //g'| sed 's/ *netmask.*$//g'
				#最后面的 ' *' 是非常重要的,表示无限多个空格, .*$ 选中无限多个任意字符 直到最后.

范例:只取出 MAN 开头的数据行, 不需要 # 开头的注视.
  $cat /etc/man_db.conf | grep 'MAN'| sed 's/#.*$//g' | sed '/^$/d'
  				#这么写可以,但是很混乱. 可以使用下面的代替(解决问题的方法很多,不要死脑筋)
  				$cat /etc/man_db.conf | grep -v '^#.*' | grep '^MAN.*'


范例 : 利用 sed 将 reg.txt 每一行结尾为 . 的变成 !
$sed -i 's/\.$/\!/g' reg.txt

范例 :将 reg.txt 末行添加一串字符串. 'this is a test'
$sed -i '$a this is a test' reg.txt
				# $代表最后一行 . a 的动作是新增, 因此在该文件最后新增字符串.
```



##  延伸正则表达式 

**注意:    `!`  和 ` >` 并不是正则表达式的特殊字符, 所以他俩没有任何意义. 可以直接参与寻找.**

| 字符 | 意义与范例                                                   |
| :--: | ------------------------------------------------------------ |
|  +   | 重复“一个或一个以上”的前一个 RE 字符.也就是说必须要有一个 RE 字符 |
|  ?   | “零个或一个”的前一个 RE 字符. 限制了 一个或零个              |
|  \|  | 用或( or )的方式找出数个字串, 也就是写在一起的二次查询       |
| ( )  | 找出"群组"字串,也就是集合,  `$egrep -n 'g(la|oo)d'`   既会搜索 glad 也会搜索 good |
| ( )+ | 多个重复群组的判别, ·`echo 'AxyzxyzxyzxyzC' | egrep 'A(xyz)+C'` 会输出 `AxyzxyzxyzxyzC` |



## 文件内容的格式化于相关处理

**printf  并不是管道命令**

```bash
$ printf '打印格式' 实际内容   
选项与参数:
	关于格式方面的几个特殊样式:
		\a 警告声音输出
		\b 倒退键(backspace)
		\f 清除屏幕 (form feed)
		\n 输出新的一行
		\r 亦即 Enter 按键
		\t 水平的 [tab] 按键
		\v 垂直的 [tab] 按键
		\xNN NN 为两位数的数字，可以转换数字成为字符。 '\X74'  会输出 t 
关于 C 程序语言内，常见的变量格式
		%ns 那个 n 是数字， s 代表 string ，亦即多少个字符;
		%ni 那个 n 是数字， i 代表 integer ，亦即多少整数位数;
		%N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数的浮点数.
				  假设我共要十个位数，但小数点有两位，即为 %10.2f 啰! 即 1234567.89

范例: 将 printf.txt 内的数据进行格式化输出.
$printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt  )
输出:
    DmTsai    80    60    92 77.3 
     VBird    75    55    80 70.0 
       Ken    60    90    70 73.3 
# %10s 表示字符串长度为10,  %5i 表示整数长度为5位. %8.2f 表示8位浮点数 5位整数+2位小数+1个小数点
#  后面的\n 必须要有, 那是换行的标示
```



#### swk 好用的数据处理工具










































