

```c++
#include <iostream>

//  #include "/include/linux/list.h"   // 从内核跟路径开始,这个是内核的双向循环链表头文件





struct list_head{
    struct  list_head *next;
    struct  list_head *prev;
};




struct  fox{
    int tail_length;
    list_head  list;
};





// 通过链表结构来会计算 当前节点的头部位置,并返回当前节点的指针
#define container_of(ptr, type, member) ({            \
    const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
    (type *)( (char *)__mptr - offsetof(type,member) );})
/* 可以换算成如下内容:
     // member是链表结构体类型(list_head), type 是节点结构体类型(Data), ptr是链表结构体指针
     Data*  container_of( struct list_head * ptr, struct list_head member){
                     const typeof( ((Data *)0)->list_head ) *  __mptr = (ptr);
                     // 简化后 ->   struct list_head* __mptr = ptr;
                     
                     cosnt char* __mpt2 = (char*)__mptr;
                     __mpt2 = __mpt2 - ( sizeof(Data) - sizeof(list_head) );
                     return   (Data*)__mpt2;
     }
*/






// 返回链表中的成员
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)







// 动态初始化 链表  , 也就是运行期
static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list->next = list;
    list->prev = list;
}

// 静态初始化 链表 , 也就是编译期
#define LIST_HEAD_INIT(name) { &(name), &(name) }







#undef LIST_HEAD
// 初始化链表头, name 就是名字, 不能有类型,  但是从这里返回后, 就有了类型和空间(栈)
#define LIST_HEAD(name) \
    struct list_head name = LIST_HEAD_INIT(name)









static inline void __list_add(struct list_head *lnew,
                  struct list_head *prev,
                  struct list_head *next)
{
    next->prev = lnew;
    lnew->next = next;
    lnew->prev = prev;
    prev->next = lnew;
}

/**
 * list_add - 添加一个新条目
 * @lnew：要添加的新条目
 * @head: 列出要在其后添加的头
 *
 * 在指定的头部后插入一个新条目。
 * 这有利于实现堆栈。
 */
static inline void list_add(struct list_head *lnew, struct list_head *head)
{
    __list_add(lnew, head, head->next);
}


/**
 * list_add_tail - 在链表添加一个新条目
 * @lnew：要添加的新条目
 * @head: 列出要在其后添加的头
 *
 * 在指定的尾部后插入一个新条目。
 * 这有利于实现堆栈。
 */
static inline void list_add_tail(struct list_head *lnew, struct list_head *head)
{
    __list_add(lnew, head->prev, head);
}







static inline void __list_del(struct list_head * prev, struct list_head * next)
{
    next->prev = prev;
    prev->next = next;
}
/**
 * list_del - 从列表中删除条目。
 * @entry：要从列表中删除的元素。
 * 注意：list_empty() 在此之后不会返回 true，条目是处于未定义状态。
 */
static inline void list_del(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
}







/**
 * list_move - 从一个列表中删除并添加为另一个列表
 * @list: 要移动的条目
 * @head：在我们进入之前的头部

  *     会将 list 插入到 head 后面, 并且将 list 从原本链表中删除
 */
static inline void list_move(struct list_head *list, struct list_head *head)
{
    __list_del(list->prev, list->next);
    list_add(list, head);
}


/**
 * list_move_tail - 从一个列表中删除并添加为另一个列表的尾部
  * @list: 要移动的条目
  * @head：跟随我们进入的头部
 */
static inline void list_move_tail(struct list_head *list,
                  struct list_head *head)
{
    __list_del(list->prev, list->next);
    list_add_tail(list, head);
}






/**
 * list_del_init - 从列表中删除条目并重新初始化它。
  * @entry：要从列表中删除的元素。
 */
static inline void list_del_init(struct list_head *entry)
{
    __list_del(entry->prev, entry->next);
    INIT_LIST_HEAD(entry);
}





/**
 * list_empty - 测试列表是否为空
 * @head：要测试的列表。
 *   为空时返回 true
 */
static inline int list_empty(const struct list_head *head)
{
    return head->next == head;
}








static inline void __list_splice(const struct list_head *list,
                 struct list_head *prev,
                 struct list_head *next)
{
    struct list_head *first = list->next;
    struct list_head *last = list->prev;

    first->prev = prev;
    prev->next = first;

    last->next = next;
    next->prev = last;
}


/**
 * list_splice - 连接两个列表，这是为堆栈设计的
  * @list：要添加的新列表。
  * @head：将其添加到第一个列表中的位置。
 */
static inline void list_splice(const struct list_head *list,
                struct list_head *head)
{
    if (!list_empty(list))
        __list_splice(list, head, head->next);
}


/**
 * list_splice_init - 加入两个列表并重新初始化清空列表。
  * @list：要添加的新列表。
  * @head：将其添加到第一个列表中的位置。
  *
  * 重新初始化@list 中的列表
 */
static inline void list_splice_init(struct list_head *list,
                    struct list_head *head)
{
    if (!list_empty(list)) {
        __list_splice(list, head, head->next);
        INIT_LIST_HEAD(list);
    }
}










// __builtin_prefetch() 是 gcc 的一个内置函数。它通过对数据手工预取的方法，减少了读取延迟，从而提高了性能，但该函数也需要 CPU 的支持。
#define prefetch(x) __builtin_prefetch(x)


/**
 * list_for_each - 遍历一个列表
  * @pos: &struct list_head 用作循环游标。
  * @head：列表的头部。
 */
#define list_for_each(pos, head) \
    for (pos = (head)->next; prefetch(pos->next), pos != (head); \
            pos = pos->next)

/**
 * __list_for_each - 遍历一个列表
  * @pos: &struct list_head 用作循环游标。
  * @head：列表的头部。
  * 此变体与 list_for_each() 的不同之处在于它是最简单的列表迭代代码，不进行预取。
 *  将此用于大多数时间知道列表非常短（空或 1 个条目）的代码。
 */
#define __list_for_each(pos, head) \
    for (pos = (head)->next; pos != (head); pos = pos->next)

/**
 * list_for_each_prev - 向后迭代列表
  * @pos: &struct list_head 用作循环游标。
  * @head：列表的头部。
 */
#define list_for_each_prev(pos, head) \
    for (pos = (head)->prev; prefetch(pos->prev), pos != (head); \
            pos = pos->prev)


/**
 * list_for_each_entry - 迭代给定类型的列表, 比 list_for_each()  更加方便
  * @pos：  用作循环游标的类型 *。
  * @head：列表的头部。
  * @member: struct 中 list_struct 的名称。
 */
#define list_for_each_entry(pos, head, member)                \
    for (pos = list_entry((head)->next, typeof(*pos), member);    \
         prefetch(pos->member.next), &pos->member != (head);     \
         pos = list_entry(pos->member.next, typeof(*pos), member))


/**
 * list_for_each_entry_reverse - 向后迭代给定类型的列表。
  * @pos：用作循环游标的类型 *。
  * @head：列表的头部。
  * @member: struct 中 list_struct 的名称。
 */
#define list_for_each_entry_reverse(pos, head, member)            \
    for (pos = list_entry((head)->prev, typeof(*pos), member);    \
         prefetch(pos->member.prev), &pos->member != (head);     \
         pos = list_entry(pos->member.prev, typeof(*pos), member))






/**
 * list_for_each_entry_safe - 迭代给定类型的列表，防止删除列表条目
  * @pos：用作循环游标的类型 *。
  * @n：另一种类型 * 用作临时存储
  * @head：列表的头部。
  * @member: struct 中 list_struct 的名称。
 */
#define list_for_each_entry_safe(pos, n, head, member)            \
    for (pos = list_entry((head)->next, typeof(*pos), member),    \
        n = list_entry(pos->member.next, typeof(*pos), member);    \
         &pos->member != (head);                     \
         pos = n, n = list_entry(n->member.next, typeof(*n), member))


/**
 * list_for_each_entry_safe_reverse - 向后迭代列表安全防止删除
  * @pos：用作循环游标的类型 *。
  * @n：另一种类型 * 用作临时存储
  * @head：列表的头部。
  * @member: struct 中 list_struct 的名称。
  *
  * 向后迭代给定类型的列表，防止删除列表条目。
 */
#define list_for_each_entry_safe_reverse(pos, n, head, member)        \
    for (pos = list_entry((head)->prev, typeof(*pos), member),    \
        n = list_entry(pos->member.prev, typeof(*pos), member);    \
         &pos->member != (head);                     \
         pos = n, n = list_entry(n->member.prev, typeof(*n), member))






int main(void){

    fox  *data0 = new fox, *data1 = new fox, *data2 = new fox;
    fox * data3 = new fox ;
    
    data0->tail_length=0;
    data1->tail_length=1;
    data2->tail_length=2;
    data3->tail_length=3;

// 动态 初始化 链表
    INIT_LIST_HEAD ( &data0->list );
    INIT_LIST_HEAD ( &data1->list );
    INIT_LIST_HEAD ( &data2->list );
    INIT_LIST_HEAD ( &data3->list );
//  如果是在编译期静态创建的结构 那么用下面的方式来进行初始化, (全局变量)
    //struct Data fox{
    //  .a = 99,
    //  .list = LIST_HEAD_INIT(fox.list),
    //    // 拆解:   .list = { &(fox.list) , $(fox.list)}, //就是结构体赋值
    //};
    
    
    
// 链表头,  name 就是名字, 不能有类型,  但是从这里返回后, 就有了类型和空间(栈)
    LIST_HEAD(head);
    
// 给链表增加一个节点
    list_add ( &data0->list, &head);   // 默认会插入到前面
    list_add_tail ( &data1->list, &head);   // 默认插入到最后面
    list_add_tail ( &data2->list,  &head);
    list_add_tail ( &data3->list, &head );
    
// 从链表删除一个节点
    list_del(&data3->list);
    delete data3;
 

// 链表循环
    {
        struct  list_head *p ;
        struct  fox  * foxP;
        list_for_each(p, &head){
            foxP = list_entry(p, struct fox, list);
            std::cout << "第一种  " << foxP->tail_length << std::endl;
        }
        std::cout << std::endl;
    }
// 链表循环  第二种
    {
        struct  fox  * foxP;
        list_for_each_entry(foxP, &head, list){
            std::cout << "第二种  " << foxP->tail_length << std::endl;
        }
        std::cout << std::endl;
    }
    
// 链表循环  第三种, 反向循环
        {
            struct  fox  * foxP;
            list_for_each_entry_reverse(foxP, &head, list){
                std::cout << "第三种: 反向循环  " << foxP->tail_length << std::endl;
            }
            std::cout << std::endl;
        }

// 循环删除
    {
        struct fox* temp0 = new fox;
        struct fox* temp1 = new fox;
        struct fox* temp2 = new fox;
        
        temp0->tail_length = temp1->tail_length = temp2->tail_length = 55;
        
        list_add (&temp0->list, &head);
        list_add (&temp1->list, &head);
        list_add (&temp2->list, &head);

        
        struct fox  *pos, *n ;
        
        list_for_each_entry_safe(pos, n , &head, list){
            std::cout << "循环删除, 这个是被删除的节点  " << pos->tail_length << std::endl;
            delete  pos;  // 删除的是 pos
        }
        INIT_LIST_HEAD(&head);
    }
    
    
    
    
//    typeof ( list_entry( &data2->list, fox, list )) pd = list_entry( &data2->list, fox, list );
//    pd->tail_length = 10;
//    std::cout<<  list_entry( &data1->list, fox, list )->tail_length  << std::endl;  // 会输出1
//    std::cout<<  list_entry( &data2->list, fox, list )->tail_length  << std::endl;  // 会输出2
}

```

