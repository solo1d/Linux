- [内核中的时间概念](#内核中的时间概念)
- [节拍率HZ](#节拍率HZ)
- [jiffies](#jiffies)
- [硬时钟和定时器](#硬时钟和定时器)
- [时钟中断处理程序的实现](#时钟中断处理程序的实现)
- [定时器](#定时器)
- [延迟执行](#延迟执行)
- [schedule_timeout函数](#schedule_timeout函数)
- 









==**1GHZ的处理器 的 时钟周期 为1ns (纳秒), 相当于 1秒十亿次**==

$1s(秒) = 1000ms(毫秒) *= 1000µs(微秒) *=1000ns(纳秒) *=1000ps(皮秒)*=1000fs(飞秒)$

- **系统定时器:  一种可编程硬件芯片, 它能以固定频率产生中断**  
  - **这个中断就是所谓的 ==定时器中断== ,  它所对应的中断处理程序负责更新系统时间, 也负责执行周期性 运行的任务**
    - **系统定时器和 时钟中断处理程序时Linux系统内核管理机制中的中枢**
- **动态定时器:  一种用来推迟执行程序工具**
  - **内核可以动态创建或撤销动态定时器**
- **内核中所有的时间概念都来源于周期运行的系统时钟**
- ==**平均误差  就是可能浪费的时间,  是时钟中断周期的一半**==
- **一秒钟内 时钟中断的次数  等于HZ**
- **内核 很少使用绝对时间**
- **当前实际时间 就是墙上时间**

# 内核中的时间概念

- **内核必须在硬件的帮助下才能计算和管理时间**
  - **硬件为内核提供了一个系统定时器  用来计算流逝的时间,  该时钟在内核中可看成是一个电子时间资源** 
    - **比如 数字时钟和处理器频率等**
- ==**节拍率**== :**系统定时器 以某种频率自行触发 `(可称为击中或射中)`  时钟中断, 这个频率可以通过编程预定 **
  - ==**当时钟中断发生时, 内核就通过一种特殊的中断处理程序对其进行处理**==
  - ==**节拍:**==  因为预编的节拍率对内核来说是可知的，所以内核知道  **连续两次时钟中断的间隔时间**。这个间隔时间就称为节拍（tick），它等于 节拍率分之一（ 1/ (tick rate））秒。
    - **内核就是靠这种已知的时钟中断间隔来计算  ==墙上时间== 和 ==系统运行时间==**
      - ==**墙上时间:**== 也就是**实际时间** 现实时间, 对用户空间的应用程序来说是最重要的。**该时间存放在 time 变量中**
        - 内核通过控制时钟中断维护实际时间，
        - 内核也为用户空间提供了一组系统调用以获取实际日期和实际时间。
      - ==**系统运行时间:**==（**自系统启动开始所经的时间**）对用户空间和内核都很有用，因为许多程序都必须清楚流逝的时间。
        - **相对的流逝的时间计算:** 通过两次（现在和以后）读取运行时间再计算它们的差，就可以得到
      - **系统运行时间以秒为单位计算, 就等于 $jiffies/HZ$**

>- **时钟中断对于管理操作系统尤为重要，大量内核函数的生命周期都离不开流近的时间的控制。**
>- **下面是一些利用 ==时间中断周期== 执行的工作：**
>  - 更新系统运行时间。
>  - 更新实际时间。
>  - 在 smp 系统上，均衡调度程序中各处理器上的运行队列,  如果运行队列负载不均衡的话，尽量使它们均衡.
>  - 检査当前进程是否用尽了自己的时间片。如果用尽，就重新进行调度
>  - 运行超时的动态定时器。
>  - **更新资源消耗和处理器时间的统计值。**
>- 这其中有些工作在毎次的时钟中断处理程序中都要被处理, 也就是说，这些工作随时钟的频率反复运行。另一些也是周期性地执行，但只需要每 n 次时钟中断运行一次，也就是说，这些函数在累计了一定数量的时钟节拍数时才被执行。



# 节拍率HZ

- **系统定时器频率 (节拍率)  是通过 ==静态预处理定义== 的, 也就是HZ(赫兹),在系统启动时按照HZ 值对硬件进行设置**
  - 处理器的体系结构不同, HZ的值也不同
  - 节拍率有一个HZ频率,一个周期为 `1/HZ` 秒。
    - 例如，x86 体系结构中，系统定时器频率默认值为 100。因此，x86 上时钟中断的频率就为 100HZ，也就是说在 i386 处理上的毎秒钟时钟中断 100 次（百分之一秒，即每 10ms 产生一次）。但其他体系结构的节拍率为 250 和 1000, 分别对应 4ms 和 1ms。
  - ==**HZ值是可调的, 并不是固定不变, 編写内核代码时, 大多数体系结构的节拍率都是可调的**==
  - ==**在 2.6 版内核中还是允许在编译内核时选定不同的 HZ 值**==

```c
#include <arch/x86/include/sam/param.h>  // HZ定义 , 根处理器的体系结构相关

# define HZ		CONFIG_HZ	/* 内部内核定时器频率*/
# define USER_HZ	100		/* 用户看到的HZ频率值 */
# define CLOCKS_PER_SEC	(USER_HZ)       /* in "ticks" like times() */

// 内核使用 jiffies_64_to_clock_t() 将64位 的jiffies值的单位从 HZ 转换为 USER_HZ, 方便计算
   u64 jiffies_64_to_clock_t(u64 x);

// 例子: 把 节拍数/HZ 得到的 经过了多少节拍
  unsigned long total_time  , start = jiffies 
   /* 中间执行了一些任务, 消耗了一些时间 */
  totla_time = jiffies - start;
  printk("这花了 %lu 节拍\n", jiffies_64_to_clock_t(total_time));
  printk("这花了 %lu 秒\n", total_time / HZ);
```

- 系统定时器使用 **高频率** 与 使用 **低频率**  的优劣:
  - ==高频率 HZ 的好处:==
    - 提高节拍率意味着时钟中断产生得更加频繁，所以中断处理程序也会更频地执行。如此来会给整个系统带来如下 **好处**：
      - 更高的时钟中断解析度（resolution）可提高时间驱动事件的解析度
        - 提高节拍率等同于提高中断解析度。比如 HZ=100 的时钟的执行粒度为 10ms，即系统中的周期事件最快为每 10ms 运行一次，而不可能有更高的精度，但是当 HZ=1000 时，解析度就为1ms 精细了 10 倍。内核可以提供频度为 1ms 的时钟.
      - 提高了时间驱动事件的准确度（accuracy）。
        - 触发定时器会更加精准, 误差更小, 平均误差也会更小
    - **更高的时钟中断频度和更高的准确度又会来如下优点：**
      - 内核定时器能够以更高的频度和更高的准确度运行。
      - 依赖定时值执行的系统调用，比如 pol 和 selecto，能够以更高的精度运行。
      - 对诸如资源消耗和系统运行时间等的测量会有更精细的解析度提高进程抢占的准确度。
      - 提高精度可以大幅度提高系统性能
      - 更高的准确率也使进程抢占更准确，同时还会加快调度响应时间
        - **时钟中断处理程序负责减少当前进程的时间片计数。**
          - 当时间片计数跌到 0 时，而又设置了 need_resched 标志的话，内核便立刻重新运行调度程序。
            - 假定有一个正在运行的进程，它的时间片只剩下 2ms 了，此时调度程序又要求抢占该进程，然后去运行另一个新进程；然而，该抢占行为不会在下个时钟中断到来前发生，也就是说，在这 2ms 内不可能进行抢占。实际上，对于频率为 100HZ 的时钟来说，最坏要在 10ms 后，当下一个时钟中断到来时才能进行抢占，所以新进程也就可能要比要求的晚 10ms 才能执行。当然，进程之间也是平等的，因为所有的进程都是一视同仁的待遇，调度起来都不是很准确但关不在于此。问题在于由于耽误了抢占，所以对于类似于填充音频缓冲区这样有严格时间要求的任务来说，结果是无法接受的。如果将节拍率提高到 1000Z，在最坏情况下，也能将调度延误时间降低到 ms，而在平均情况下，只能降到 0.5ms 左右。
  - ==高频率 HZ 的坏处:==
    - **节拍率越高，意味着时钟中断频率越高，就意味着系统负担越重**
    - 因为处理器必须花时间来执行时钟中断处理程序，所以节拍率越高，中断处理程序占用的处理器的时间越多。
    - 减少处理器处理其他工作的时间，而且还会更频繁地打乱处理器高速缓存并增加耗电。
    - 将时钟频率从 100HZ 提高到 1000HZ 必然会使时钟中断的负载增加 10 倍。



# jiffies

- **全局变量 jiffies 用来记录自系统启动以来产生的节拍的总数。**
  - 启动时 , 内核将该变量初始化为一个特殊值,让它不断溢出,  由此捕捉异常，但每次时钟中断处理程序就会增加该变量的值。
    - **找到这个值的时候, 需要先把这个内核加上的 偏差值  减去  才可正常使用**
  - **一秒钟内 时钟中断的次数  等于HZ, jiffies 一秒内增加的值也为HZ**
  - **系统运行时间以秒为单位计算, 就等于  $(jiffies/HZ)$**
- **用户空间使用的HZ 和系统的HZ 不一样. 但可以互相转换**

```c
#include <include/linux/jiffies.h>
#define __jiffy_data  __attribute__((section(".data")))

// 64位体系结构是64位, 32位体系结构是32位(100HZ 下会在497天溢出 0xFFFFFFFF/100/60/60/24=497 )
// 大多数代码只关系 低32位 来使用 流失的时间
extern unsigned long volatile __jiffy_data  jiffies;  
extern u64 __jiffy_data jiffies_64;  // 64位体系结构下, 他和 jiffies指向同一变量,作用相同


// 将以秒为单位的时间 转化为 jiffies  , 这个在内核里常用
( seconds * HZ)

// 将 jiffies 转换为 以秒为单位的时间 , 经常用在内核和用户空间进行交互的时候.
( jiffies / HZ )


// 设置一些将来的时间
unsigned long time_stamp = jiffies;      // 现在
unsigned long time_data = jiffies/HZ;    // 从开机到现在 过去了多长时间 (有可能要减去某个特殊值)
unsigned long next_tick = jiffies + 1;   // 从现在开始的一个节拍
unsigned long later = jiffies + 5*HZ;    // 从现在开始 5 秒
unsigned long fraction = jiffies + HZ/10;  // 从现在开始 1/10 秒



// 读取整个 64位 jiffies 的值 ( 32位体系结构下是 32位),  也可以直接读取 jiffies 变量来获得
		u64 get_jiffies_64(void);


// 当 jiffies 发生溢出  回绕到 0时, 可以通过下面的宏来进行正确的处理
//  比较的时候用这些宏可以避免jiffies由于过大造成的回绕问题。
// unknown 通常为 jiffies,  known是需要对比的值, 如果有参数为0   则直接返回 0

long time_after(unknown, known)	 ((long)(known) - (long)(unknown) < 0)
    // 当时间 unknow 超过指定的 know 时, 返回真, 否则假
long time_before(unknown, known)	 ((long)(unknown) - (long)(known) < 0)
      // 当时间 unknow 没超过指定的 know 时, 返回真, 否则假
long time_after_eq(unknown, known)	 ((long)(unknown) - (long)(known) >= 0)
      // 当时间 unknow 与 know 相等时, 返回真, 否则假
long time_before_eq(unknown, known)	 ((long)(known) - (long)(unknown) >= 0)
      // 当时间 unknow 与 know 相等时, 返回真, 否则假
  
  
// 例子:
    unsigned long timeout = jiffies + HZ/2;
       /* 中间执行了一些任务, 消耗了一些时间 */
    if(time_before(jiffies, timeout)){
       // 没有超时
    } else{
       // 超时了  发生错误
    }
  
```



# 硬时钟和定时器

- **实时时钟 `RTC`   是个硬件, 用来存放持久系统时间的设备, 靠主板的2032电池保持供电和系统的计时**
  - RTC 一般和 CMOS集成在一起, RTC 的运行和 BIOS 的保存设置都是通过同一个电池供电的。
  - ==**实时时钟最主要的作用仍是在启动时初始化 xtime 变量。**==
    - ==当系统启动时，内核通过读取 RTC 来初始化墙上时间，该时间存放在 **xtime** 变量中。==
  - 内核通常不会在系统启动后再读取 xime 变量，但是有些体系结构（比如 x86) 会周期性地将当前时间值存回 RTC 中。
- **系统定时器 是一个硬件,  是内核定时机制中最为重要的角色, 提供一种周期性触发中断机制**
  - **通过对电子晶振进行分频来实现系统定时器，还有些体系结构则提供了一个衰减测量器(decrementer）衰减测量器设置一个初始值，该值以固定频率递减，当减到零时，触发一个中断。无论哪种情况，其效果都一样**
  - 在 x86 体系结构中，主要采用可编程中断时钟（PIT）。PT 在 PC 机器中普遍存在，而且从 DOS 时代，就开始以它作为时钟中断源了。
  - 内核在启动时对 PIT 进行编程初始化, 使其能够以 HZ/秒的频率产生时钟中断(中断O)。虽然PT设备很简单,功能也有限，但它却足以满足我们的需要。x86 体系结构中的其他的时钟资源还包括本地 APIC 时钟和时间戳计数（TSC）等。



# 时钟中断处理程序的实现

- **时钟中断处理程序可以划分为两部分:   体系结构相关部分和体系结构无关部分**
  - **体系结构相关部分**
    - 与体系结构相关的例程作为系统定时器的中断处理程序而注册到内核中，以便在产生时钟中断时，它能够相应地运行。	
    - ==**绝大多数处理程序最低限度也都要执行如下工作：**==
      - 获得 time_lock 锁，以便对访问 jiffies_64 和墙上时间 time 进行保护
      - 需要时应答或重新设置系统时钟。
      - 周期性地使用墙上时间更新实时时钟。 xtime
      - **调用体系结构无关的时钟例程：`tick_periodic()`**
        - ==**中断服务程序主要通过调用与体系结构无关的例程，`tick_periodico()` 执行下面更多的工作:**==
          - 给 jiffies_64 变量增加 1（这个操作即使是在 32 位体系结构上也是安全的，因为前面已经获得了 time_lock 锁）
          - **更新资源消耗的统计值，比如当前进程所消耗的系统时间和用户时间。**
          - **执行已经到期的动态定时器**
          - 执行 `sheduler_tick()` 函数
          - **更新墙上时间，该时间存放在 time 变量中**
          - **计算平均负载值。**
  - **体系结构无关部分**
    - 



**下面的全部函数和工作 在每  `( 1/HZ )秒`  都要发生一次, 100HZ 就表示会发生 100次  , 从函数 `tick_periodic()` 开始**

```c
/*  #include <kernel/sched.c>
 * 负责减少当前运行进程的时间片计数值 并且在需要时设置 need_resched 标志.
 *  在SMP机器中, 还要负责平衡每个处理器上的运行队列
 * 此函数由定时器代码调用，频率为 HZ。
 * 我们在禁用中断的情况下调用它。
 * 在更改父级的时间片时，它也会被 fork 代码调用。
 */
void scheduler_tick(void)
{
	int cpu = smp_processor_id();
	struct rq *rq = cpu_rq(cpu);
	struct task_struct *curr = rq->curr;

	sched_clock_tick();

	raw_spin_lock(&rq->lock);
	update_rq_clock(rq);
	update_cpu_load(rq);
	curr->sched_class->task_tick(rq, curr, 0);
	raw_spin_unlock(&rq->lock);

	perf_event_task_tick(curr);

#ifdef CONFIG_SMP
	rq->idle_at_tick = idle_cpu(cpu);
	trigger_load_balance(rq, cpu);
#endif
}



/* #include <kernel/timer.c>
 * 64 位 jiffies 值不是原子的 - 您不得在不对 xtime_lock 中的序列号进行采样的情况下读取它。
 *   jiffies 在链接描述文件中定义...
 * 更新 jiffies_64 墙上时间, 和计算全局负载
 */
void do_timer(unsigned long ticks)
{
	jiffies_64 += ticks;
	update_wall_time();  //  根据所流的时间更新 jiffies_64 墙上时间
	calc_global_load();  // 更新系统的平均负载统计值。
}


/* #include <kernel/sched.c>
 * 对进程的时间进行实质性更新
 * 计算 CPU 时间的一个滴答。
 * @p：cpu 时间占用的进程
 * @user_tick: 表示tick是用户还是系统tick
 */
void account_process_tick(struct task_struct *p, int user_tick)
{
	cputime_t one_jiffy_scaled = cputime_to_scaled(cputime_one_jiffy);
	struct rq *rq = this_rq();

	if (user_tick)
		account_user_time(p, cputime_one_jiffy, one_jiffy_scaled);
	else if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))
		account_system_time(p, HARDIRQ_OFFSET, cputime_one_jiffy,
				    one_jiffy_scaled);
	else
		account_idle_time(cputime_one_jiffy);
}




/* #include <kernel/timer.c >
 * 从定时器中断处理程序中调用，以向当前进程更新节拍数。 
 * user_tick 如果是用户时间，则为 1，系统为 0。 表示这个时间是花费在 内核还是用户空间,但不准确
 * user_tick 是通过查看 系统寄存器 来设置的
 */
void update_process_times(int user_tick)
{
	struct task_struct *p = current;
	int cpu = smp_processor_id();

	/* 注意：这个计时器 irq中断请求 上下文也必须考虑在内, 对这个 时钟的irq中断请求 的上下文 说明原因*/
	account_process_tick(p, user_tick);  // 对进程的时间进行实质性更新
	run_local_timers();   // 标记了一个软中断 去处理所有到期的定时器
	rcu_check_callbacks(cpu, user_tick);
	printk_tick();
	perf_event_do_pending();
	scheduler_tick();
	run_posix_cpu_timers(p);
}



/* #include <kernel/time/tick-common.c >
 * 定期节拍
 * 函数执行完毕后返回与体系结构相关的中断处理程序，继续执行后面的工作释放 time_lock 锁，然后退出。
 */
static void tick_periodic(int cpu)
{
	if (tick_do_timer_cpu == cpu) {
		write_seqlock(&xtime_lock);   // 获得顺序锁 的写锁

		/* 记录下一个节拍事件 */
		tick_next_period = ktime_add(tick_next_period, tick_period);

		do_timer(1); // 对 jiffies_64 的更新 增加
		write_sequnlock(&xtime_lock);  // 释放 顺序锁的写锁
	}
  
	/* 更新所消耗的 各种节拍数
	 * user_tick 是通过查看 系统寄存器 来设置的
	 */
	update_process_times(user_mode(get_irq_regs()));
  
	profile_tick(CPU_PROFILING);  // 什么都不做 直接return
}

```





## 实际时间

**当前实际时间 就是墙上时间, 定义在 `<kernel/time/timekeeping.c>` 中**

```c
#include <kernel/time/timekeeping.c> 
struct timespec xtime ;  
/* 实际时间( 墙上时间) 会放到这个结构里面   
 * 读写 time 变量需要使用 time_lock 锁，该锁不是普通自旋锁而是一个 seqlock 顺序锁，
 * 除了更新xtime之外, 只有在文件系统的实现代码中存放访问时间戳(创建,存取,修改等)才需要访问这个变量
 * 下面有更新范例细节
 */



#include <include/linux/time.h>
struct timespec {
	__kernel_time_t	tv_sec;		/* seconds 秒 ,存放着从 1970年1月1日(UTC) 以来经过的时间(纪元) 秒数*/
	long		tv_nsec;		/* nanoseconds 纳秒, 记录自上一秒开始经过的 纳秒数*/
};






//更新 xtime 首先要申请一个 seqlock 顺序锁
write_seqlock(&xtime_lock);
  /* 更新 xtime,   xtime=xxxx; */
write_sequnlock(&xtime_lock);

// 读取 xtime 要使用 read_seqbegin() 和 read_seqretry() 函数
void do_gettimeofday(struct timeval *ktv){
  unsigned long seq;
  do {
     unsigned long lost;
     seq = read_seqbegin(&xtime_lock);
     usec = timer->get_offset();
     lost = jiffies - wall_jiffies;
     if(lost)
        usec += lost * (1000000 / HZ);
     sec = xtime.tv_sec;
     usec += (xtime.tv_nsec / 1000);
  }while (read_seqretry(&xtime_lock, seq));
}
   // 该循环不断重复，直到读者确认读取数据时没有写操作介入  才会返回.
   // 如果发现循环期间有时钟中断处理程序更新 xime，那么 read_seqretryo 函数就返回无效序列号,继续循环等待.





// 从用户空间取得墙上时间的主要接口时 gettimeofday() , 在内核中对应系统调用时 sys_gettimeofday() 
// 替代了  time() 系统调用
#include <kernel/time.c >
asmlinkeage long sys_gettimeofday(struct timeval *tv, struct timezone *tz){
  if(likely(tv)){     
     struct timeval ktv;
     do_gettimeofday(&ktv);  // 执行的就是上面循环读取 xtime 的函数
     if(copy_to_user(tv, &ktv, sizeof(ktv)))
        return -EFAULT;
  }
  if(unlikely(tz))
      if(copy_to_user(tz, &sys_tz, sizeof(sys_tz)))  // 把系统时区(在sys_tz中) 返回给用户
          return -EFAULT;  // 如果给用户拷贝墙上时间或时区 时 发生错误, 就返回 -EFAULT错误
  return 0;   // 返回0  表示成功
}
 
```





# 定时器

**定时器（有时也称为动态定时器或内核定时器）是管理内核流逝的时间的基础。**

**内核经常需要推后执行某些代码,**

==**内核定时器解决的问题: 能够使工作在某个指定的时间点上执行**==

**定时器与当前执行代码是异步的**

- **定时器作为软中断在下半部  中断上下文中执行**

- **内核在时钟中断发生后 执行定时器**

  - **时钟中断处理程序会执行 `update_process_times()` 函数,该函数还会调用 `run_local_timers()` 函数**

  - ```c
    //run_local_timers() 函数处理软中断 TMER_SOFTIRQ，从而在当前处理器上运行所有的（如果有的话）超时定时器。
    void run_local_timers(void){
      hrtimer_run_queues();
      raise_softirq(TIMER_SOFTIRQ);  // 执行定时器软中断
      softlockup_tick();
    }
    ```

  - 

- **动态定时器**
  - **使用流程:**
    - 执行一些初始化工作
    - 设置一个超时时间
    - 指定超时发生后执行的函数
    - 激活定时器
  - **指定的函数将在定时器到期时自动执行。但定时器不周期运行，它在超时后就自行撤销**
  - 动态定时器不断地创建和撤销，而且它的运行次数也不受限制。
  - 定时器在内核中应用得非常普遍
- **不可以用定时器来 执实现任何硬件 实时任务**

> 虽然所有定时器都以链表形式存放在一起，但是让内核经常为了寻找超时定时器而遍历整个链表是不明智的。为了提高效率，内核将定时器按它们的超时时间划分为**五组**。当定时器超时时间接近时，**定时器将随组一起下移**。采用分组定时器的方法可以在执行软中断的多数情况下，确保内核尽可能减少搜索超时定时器所带来的负担。因此定时器管理代码是非常高效的。

```c
#include <include/linux/timer.h >
// 定时器结构
struct timer_list {
	struct list_head entry;  // 定时器链表入口
	unsigned long expires;   // 以 jiffies 为单位的定时值
	void (*function)(unsigned long); // 定时器 到点后  执行的处理函数
	unsigned long data;  // 传给 function 处理函数的 长整形参数
	struct tvec_base *base;  // 定时器内部值, 用户不要使用
};


// #include <include/linux/timer.h>
// #include <kernel/timer.c>
//内核在时钟中断发生后 执行定时器
// 定时器作为软中断在下半部  中断上下文中执行
// 内核提供接口来 管理定时器的操作
// 下面是流程

 void my_function(unsigned long data);   
struct timer_list my_timer;  // 先定义
init_timer(&my_timer);   // 初始化定时器数据结构的内部值
 my_timer.expires = jiffies + delay;   // 定时器超时 时的节拍数,到达这个节拍数之后 就会触发和执行
 my_timer.data = 0;                    // 给定时器处理函数传入参数  值为  0
 my_timer.function = my_function;      // 定时器超时 时调用的函数
 add_timer(&my_timer) ;    // 激活定时器,  这样才会开始工作
 
//还可以更改定时器的超时时间, 也就是 处理函数的运行时间点  , 也会激活定时器
// 返回值: 原本 my_timer 是激活状态时  返回1, 非激活状态时 返回0
int mod_timer(&my_timer, jiffies + new_delay);  // 后面参数就是新的时间点( 节拍) 

//// 已经执行的定时器  会被自动删除.
// 等待所有处理器上 运行的定时器处理程序的退出之后,  停止和删除 定时器
del_timer_sync(&my_timer);  // 绝对不可以在中断上下文中使用, 但却更加安全, 应该使用这个

// 已经执行的定时器  会被自动删除.
// 停止定时器处理函数的执行(不保证会删除定时器), 也就是未超时,  但绝不可以对已经超时的定时器调用这个函数
del_timer(&my_timer);  // 不安全,  不建议使用
```





# 延迟执行

**推迟通常发生在等待硬件完成某些工作时，而且等待的时间往往非常短，**

- **有些延迟任务会挂起处理器, 防止处理器执行任何实际工作**
- **有些延迟不会挂起处理器, 但不能保证被延迟的代码能够在指定的延迟时间运行**

- **忙等待:**
  - 忙循环  或调度其他新程序
  - `cond_resched()` 忙等待, 将调度一个 **新程序** 投入运行, 需要设置 need_resched 标志才能生效.
    - 不可以在中断上下文运行, 不可以在持有锁和禁止中断时发生
- **短延迟:**
  - 更短 更精确的延迟要求

```c
#include <include/linux/delay.h>
#include <arch/x86/include/asm/delay.h>

// 短延迟函数
//下面的函数并不使用 jiffies , 指定的延迟时间
void mdelay(unsigned long msecs);  //毫秒 
void udelay(unsigned long usecs);  //微妙 , 不应该指定大于 1000的值(1毫秒)
void ndelay(unsigned long nsecs);  //纳秒 , 不应该指定大于 1000的值(1微秒)

udelay() 函数依靠执行数次循环到达延迟效果, 内核知道处理器在1秒之内能执行多少次循环, 仅仅需要根据指定的延迟时间在1秒中占的比例, 就能决定需要进行多少次循环即可达到要求的推迟时间.
mdelay() 函数是通过 udelay() 函数实现的


BogoMIPS 值记录处理器在给定时间内忙循环执行的次数,就是处理器在空闲时速度有快.存放在 loops_per_jiffy 值中.
  可以在 /proc/cpuinfo 中读到 
延迟循环函数使用 loop_per_jiffy值来计算 为提供精确延迟而需要进行多少次循环
内核在启动时利用 calibrate_delay() 计算 loops_per_jiffy 值, 函数在文件 /init/main.c
```



## schedule_timeout函数

- `schedule_timeout()` 函数
  - 会睡眠
  - 运行在进程上下文
  - 可不持有锁
  - 在调度前 必须指定 两种中断状态的一种 (TASK_INTERRUPTIBLE  或者 TASK_UNINTERRUPTIBLE )
    - 通过 `set_current_state(TASK_INTERRUPTIBLE)` 设置
- **会让当前任务进入睡眠, 然后等待延迟时间耗尽, 被内核唤醒, 并将其重新放回运行队列, 准备运行**
- 



```c
#include <kernel/timer.c>
// 延迟时间参数为  节拍,  也就是 多少个中断周期  (1GHZ 有 十亿节拍)
signed long  schedule_timeout(signed long timeout)
{
	struct timer_list timer;  // 创建了一个定时器
	unsigned long expire;    

	switch (timeout)  
	{
	case MAX_SCHEDULE_TIMEOUT:  // 用于检查 任务是否无限期的睡眠 , 如果为真,则不需要定时器
		schedule();
		goto out;
	default:
		if (timeout < 0) {
			printk(KERN_ERR "schedule_timeout: wrong timeout "
				"value %lx from %p\n", timeout, __builtin_return_address(0));
			current->state = TASK_RUNNING;
			goto out;
		}
	}

	expire = timeout + jiffies;
	
  init_timer(&tiemr);
  timer.expires = expire;
  timer.data = (unsigned long) current;  
  timer.function = process_timeout;  // 计时器 超时执行函数
  
  add_time(&timer);  // 激活定时器
  schedule();       // 任务调度
  del_timer_sync(&timer);
  
	timeout = expire - jiffies;
 out:
	return timeout < 0 ? 0 : timeout;
}

  // 计时器 超时执行的函数, 该函数会将任务设置为 TASK_RUNNING 状态, 然后将其放入运行队列
  //  如果任务被提前唤醒(信号) 那么计时器会撤销, process_timeout() 函数会返回剩余的时间
void process_timeout(int data){
  wake_up_process((task_t*) data);
}
  


// 使用范例
/* 必须在schedule_timeout() 前调用这个 将任务设置为可中断睡状态 */
 set_current_state (TASK_INTERRUPTIBLE);
/*小睡一会儿, s 秒后 唤醒 */
 schedule_timeout (s*HZ);
```

