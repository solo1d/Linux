```c
#include <stdio.h>
#include <iostream>
#include <unistd.h>




#define BITS_PER_LONG  64   // 64位操作系统

#if BITS_PER_LONG == 32
# define IDR_BITS 5
# define IDR_FULL 0xfffffffful
# define TOP_LEVEL_FULL (IDR_FULL >> 30)

#elif BITS_PER_LONG == 64
# define IDR_BITS 6
# define IDR_FULL 0xfffffffffffffffful

#endif


struct my_struct{
    int data;
};





typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;



struct rcu_head {
    struct rcu_head *next;
    void (*func)(struct rcu_head *head);
};


struct idr_layer {
    unsigned long         bitmap; /* A zero bit means "space here" */
    struct idr_layer    *ary[1<<IDR_BITS];
    int             count;     /* When zero, we can release it */
    int             layer;     /* distance from leaf */
    struct rcu_head         rcu_head;
};

struct idr {
    struct idr_layer *top;
    struct idr_layer *id_free;
    int          layers; /* only valid without concurrent changes */
    int          id_free_cnt;
    spinlock_t      lock;
};


typedef unsigned long gfp_t;

#define __GFP_DMA    ((gfp_t)0x01u)

/*
 * IDA - IDR based id allocator, use when translation from id to
 * pointer isn't necessary.
 */
#define IDA_CHUNK_SIZE        128    /* 128 bytes per chunk */
#define IDA_BITMAP_LONGS    (128 / sizeof(long) - 1)
#define IDA_BITMAP_BITS        (IDA_BITMAP_LONGS * sizeof(long) * 8)


void idr_init(struct idr *idp);
int idr_pre_get(struct idr *idp, gfp_t gfp_mask);  //成功返回 1 ,失败返回0
int idr_get_new(struct idr *idp, void *ptr, int *id);    //成功返回 1 ,失败返回0


void *idr_find(struct idr *idp, int id);
int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id);
int idr_for_each(struct idr *idp,
         int (*fn)(int id, void *p, void *data), void *data);
void *idr_get_next(struct idr *idp, int *nextid);
void *idr_replace(struct idr *idp, void *ptr, int id);
void idr_remove(struct idr *idp, int id);
void idr_remove_all(struct idr *idp);
void idr_destroy(struct idr *idp);



/**
 * idr_init - 初始化 idr 句柄
  * @idp: idr 句柄
  *
  * 此函数用于设置您将传递的句柄（@idp）
  * 到其余函数。
 */
void idr_init(struct idr *idp)
{
    memset(idp, 0, sizeof(struct idr));
//    spin_lock_init(&idp->lock);
}



/**
 * idr_pre_get - idr 分配的预留资源
  * @idp: idr 句柄
  * @gfp_mask: 内存分配标志
  *
  * 这个函数应该在锁定和调用之前调用
  * idr_get_new* 函数。它预先分配了足够的内存来满足
  * 最糟糕的分配。
  *
  * 如果系统真的内存不足，此函数返回 0，否则返回 1。
 */
int idr_pre_get(struct idr *idp, gfp_t gfp_mask)
{
    return 1;  // 成功
}



/**
 * idr_get_new_above - 分配高于或等于开始 id 的新 idr 条目
  * @idp: idr 句柄
  * @ptr：你想与id关联的指针
  * @start_id: 开始搜索的id
  * @id: 指向已分配句柄的指针
  *
  * 这是分配id函数。应该使用任何所需的锁调用它。
  *
  * 如果需要内存，它将返回-EAGAIN，您应该解锁并返回到 idr_pre_get() 调用。如果 idr 已满，它将返回 -ENOSPC。
  *
  * @id 返回@starting_id ... 0x7fffffff 范围内的值
 */
int idr_get_new_above(struct idr *idp, void *ptr, int starting_id, int *id)
{
    return 0;     // 成功返回0
}






/**
 * idr_find - 返回给定 id 的指针
  * @idp: idr 句柄
  * @id: 查找键
  *
  * 返回给定已注册的 id 的指针。一个 %NULL
  * return 表示@id 无效或您传入了 %NULL
  * idr_get_new()。
  *
  * 可以在 rcu_read_lock() 下调用此函数，前提是 节点指针生命周期得到正确管理。
 */
void *idr_find(struct idr *idp, int id)
{
    void* p;
    if (id >= (1 << 1))
        return NULL;    // 空指针失败
    return((void *)p);  // 成功
}





/**
 * idr_remove - 删除给定的 id 并释放它的插槽
  * @idp: idr 句柄
  * @id: 唯一键
 */
void idr_remove(struct idr *idp, int id)
{
    return;
}



/*
  映射就是关联数组 ( 键 UID , 值 )
 映射至少要支持的三个操作:
 
 Add (key, value);
 Remove (key);
 value = Lookup(key);
 
 allocate 操作 通过 Add 实现了生产UID 和插入键值对
 */
int main(void){
    /*
        映射一个唯一的标识数(UID)  到一个指针,
           idr数据结构用于映射用户空间的 UID
              allocate 操作 通过 Add 实现了生产UID 和插入键值对
     */
    
// 动态 初始化 idr , 只有初始化之后 才能进行使用
    struct idr  idp;
    idr_init(&idp);


// 准备分配一个新的 UID ,调整 idp 指向的 idr的大小 __GFP_DMA是内存分配例程
// 先 调整后备树的大小
    idr_pre_get(&idp, __GFP_DMA);
    
// 然后  执行获取新的 UID 加入到映射, 也可以调用idr_get_new_above()  来获取, 而且还保证唯UID的一性
    my_struct* uidPtr;  // 这个是数据
    int   newUid;
    int ret = idr_get_new_above(&idp, uidPtr, 2 ,&newUid);
    if( ret == -EAGAIN || ret == -ENOSPC ){
        // 出错了,  -EAGAIN是需要重新调用一次 idr_get_new(),  -ENOSPC 是idr已满 错误
    }
    
//通过 UID 键值  查找 实值  , newUid 是返回的 id
    struct my_struct *ptr = (struct my_struct*)idr_find(&idp, newUid);
    if( ptr == nullptr )
        return  -EINVAL;  // 出错了 , 或者UID对应的就是一个空指针
    
// 删除 UID ,  newUid 是返回的 id
    idr_remove(&idp, newUid);

    
// 释放 idr 没有使用的 内存, 但是不会释放已经在使用的内存, 内核一般是不会删除idr的, 除非强制删除或在没有其他用户 (也就是没有更多的UID) 时才能删除
    idr_destroy(&idp);
    
//手动调用删除, 强制性删除掉所有的 UID
    idr_remove_all(&idp);
    
    return 0;
}

```

