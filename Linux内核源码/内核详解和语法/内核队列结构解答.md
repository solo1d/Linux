内核队列结构 kfifo

```c
#include <stdio.h>
#include <iostream>
#include <unistd.h>




struct kfifo {
    unsigned char *buffer;    /* 保存数据的缓冲区*/
    unsigned int size;    /* 已分配缓冲区的大小 */
    unsigned int in;    /* 入口数据偏移量添加（以 % 大小表示） */
    unsigned int out;    /* 出口数据偏移量减少。 （出 % 大小） */
};




typedef unsigned  gfp_t;

/**
* 分配一个新的 FIFO 内部缓冲区 ,  该函数动态分配一个新的fifo内部缓冲区
  * @fifo：分配新缓冲区的fifo
  * @size：要分配的缓冲区的大小，必须是 2 的幂。
  * @gfp_mask: get_free_pages 掩码，传递给 kmalloc()
  *
  * 缓冲区将通过 kfifo_free() 释放。
  * 无错误返回0，否则返回错误码
 */

int kfifo_alloc(struct kfifo *fifo, unsigned int size, gfp_t gfp_mask)
{
    return 0;
}




/**
 * kfifo_in - 将一些数据放入 FIFO
  * @fifo：要使用的fifo。
  * @from：要添加的数据。
  * @len：要添加的数据的长度。
  *
  * 该函数根据空闲空间最多将@from 缓冲区中的@len 个字节复制到FIFO 中，并返回复制的字节数。
  *
  * 请注意，只有一个并发读取器和一个并发写入器，您不需要额外的锁定来使用这些功能。
 */
unsigned int kfifo_in(struct kfifo *fifo, const void *from,
                unsigned int len)
{
    return len;
}




/**
 * kfifo_out_peek - 从 FIFO 中复制一些数据，但不要将其删除
 * @fifo：要使用的fifo。
 * @to：必须复制数据的地方。
 * @len：目标缓冲区的大小。
 * @offset: 偏移到先进先出
 *
 * 此函数最多从 FIFO 复制 @offset 处的 @len 字节
 * 进入@to 缓冲区并返回复制的字节数。
 * 数据不会从 FIFO 中移除。
 */

unsigned int kfifo_out_peek(struct kfifo *fifo, void *to, unsigned int len,
                unsigned offset)
{
    return len;
}




/**
 * kfifo_out - 从 FIFO 中获取一些数据
  * @fifo：要使用的fifo。
  * @to：必须复制数据的地方。
  * @len：目标缓冲区的大小。
  *
  * 该函数最多将@len 个字节从 FIFO 复制到
  * @to 缓冲并返回复制的字节数。
  *
  * 请注意，只有一个并发读者和一个并发
  * writer，您不需要额外的锁定来使用这些功能。
 */
unsigned int kfifo_out(struct kfifo *fifo, void *to, unsigned int len)
{
    return len;
}





/**
 * kfifo_size - 以字节为单位返回 fifo 的大小
  * @fifo：要使用的fifo。
 */
static inline  unsigned int kfifo_size(struct kfifo *fifo)
{
    return fifo->size;
}



/**
 * kfifo_len - 返回 FIFO 中使用的字节数
  * @fifo：要使用的fifo。
 */
static inline unsigned int kfifo_len(struct kfifo *fifo)
{
    unsigned int    out;

    out = fifo->out;
    
    return fifo->in - out;
}


/**
 * kfifo_avail - 返回 FIFO 中可用的字节数
  * @fifo：要使用的fifo。
 */
static inline unsigned int kfifo_avail(struct kfifo *fifo)
{
    return kfifo_size(fifo) - kfifo_len(fifo);
}



/**
 * kfifo_is_empty - 如果 fifo 为空则返回 true
  * @fifo：要使用的fifo。
 */
static inline  int kfifo_is_empty(struct kfifo *fifo)
{
    return fifo->in == fifo->out;
}



/**
 * kfifo_is_full - 如果 fifo 已满则返回 true
  * @fifo：要使用的fifo。
 */
static inline  int kfifo_is_full(struct kfifo *fifo)
{
    return kfifo_len(fifo) == kfifo_size(fifo);
}





/**
 * kfifo_reset - 删除整个 FIFO 内容
  * @fifo：要清空的fifo。
 */
static inline void kfifo_reset(struct kfifo *fifo)
{
    fifo->in = fifo->out = 0;
}


/**
 * kfifo_free - 释放 FIFO 内部缓冲区
  * @fifo：要释放的fifo。
 */
void kfifo_free(struct kfifo *fifo)
{
}



int main(void){
    struct kfifo  fifo;
    int ret = 0;
    
    
    // 创建队列和初始化
    ret = kfifo_alloc ( &fifo , 8192, 0xD0);
    
    // 插入队列数据
    int  data = 1;  // 这就是数据
    ret = kfifo_in(&fifo, &data, sizeof( int ));
    
    //偷窥数据, 但不删除 , 数据会被拷贝出来
    int  outData = 0;
    ret = kfifo_out_peek(&fifo, &outData, sizeof(int), 0); // 获得头部数据
    
    
    // 队列是否为空,    非空则为真
    ret = kfifo_is_full(&fifo);
    
    // 取出头部数据,  并且移动出口偏移量
    ret = kfifo_out(&fifo, &outData, sizeof(int));
    
    // 队列是否为空,    空则为真
    ret = kfifo_is_empty(&fifo);
    
    // 清空队列中的所有数据
    kfifo_reset(&fifo);
    
    // 删除队列 释放空间
    kfifo_free(&fifo);
     
    return 0;
}

```

